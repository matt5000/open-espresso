# Open Espresso Design Document

## Target Machine: Gaggia Classic (Pre-2015, Original Model)

**Purpose:** This document specifies the design and requirements for the Open Espresso firmware, serving as the primary reference for firmware contributors, hardware builders, and web app developers.

**Scope:** This document analyzes the Gaggiuino project's architecture as prior art, identifies lessons learned, and specifies a clean-room firmware design targeting a single machine — the Gaggia Classic (pre-2015, non-Pro model). Hardware and display choices are evaluated but left open for final selection.

**Project Objective:** Provide an open-source (MIT licensed), single-MCU firmware for the Gaggia Classic that provides PID temperature control, pressure/flow profiling, a modern web interface, and safety parity with the stock machine — all buildable by a hobbyist with basic soldering skills.

### Notation

This document uses the following design languages and conventions:
- **ASCII diagrams** — architecture, wiring, and state machine views
- **C++ code snippets** — interface definitions, safety constants, and algorithm pseudocode
- **JSON / JSON Schema** — data model and profile format specifications
- **Natural-language prose** — rationale, requirements, and analysis
- **Tables** — requirements, FMEA, test plan, BOM, and pin assignments

### Operational Concept (Day-in-the-Life)

```
1. User turns on the Gaggia Classic (mains switch). PSU powers the ESP32.
2. Firmware boots in < 5 seconds. TFT shows temperature, heating progress.
3. PID heats boiler to brew setpoint (93°C default). WiFi connects asynchronously.
4. TFT shows "Ready." User selects a profile (or uses the last active one).
5. User loads portafilter, places cup on scale (BLE connects automatically).
6. User flips brew switch. Shot starts. TFT shows live pressure/flow graph.
7. Profile engine runs phases: pre-infusion → ramp → hold.
8. Shot stops automatically on weight target (36g). Pump off, solenoid opens.
9. User removes cup. System returns to IDLE.
10. Optional: user opens web app on phone to review shot data, tweak profile.
11. After 5 min idle, display dims. Machine stays warm (PID still active).
12. User turns off mains switch. All outputs safe (no power = no risk).
```

### Stakeholder Concerns and Document Map

| Stakeholder | Primary Concerns | Relevant Sections |
|-------------|-----------------|-------------------|
| **Daily user** | Reliable operation, clear display, fast workflow | 8 (UI), 10 (safety), 16 (usability reqs) |
| **Profile creator** | Profile format, phase behavior, stop conditions | 11 (profile engine), 20 ICD-05 (schema) |
| **Firmware contributor** | Module boundaries, task architecture, build targets, testing | 9 (SW arch), 16 (reqs), 18 (test plan), 20 ICD-02/03/04 |
| **Web app contributor** | REST API, WebSocket protocol, auth model | 20 ICD-01 (API) |
| **Hardware builder** | BOM, pin assignments, wiring, safety, enclosure | 10 (safety), 13-15 (HW), 20 ICD-07 |

### User Characteristics

| User Role | Description | Technical Level |
|-----------|-------------|-----------------|
| **Daily user** | Makes espresso, switches profiles, monitors shots | Non-technical. Interacts via TFT display and web app only. |
| **Profile creator** | Designs and tunes shot profiles, adjusts PID parameters | Intermediate. Understands pressure, flow, temperature concepts. Can edit JSON. |
| **Firmware contributor** | Adds features, fixes bugs, writes drivers | Developer. Fluent in C/C++, FreeRTOS, embedded systems. |
| **Web app contributor** | Builds or modifies the web UI | Developer. Fluent in HTML/CSS/JS, WebSocket, REST APIs. |
| **Hardware builder** | Assembles the electronics, wires the machine, builds the enclosure | Maker/hobbyist. Comfortable with soldering, basic electrical work, 3D printing. |

### Glossary

| Term | Definition |
|------|-----------|
| **ADS1115** | 16-bit analog-to-digital converter (Texas Instruments), I2C interface, used to read the pressure transducer |
| **BLE** | Bluetooth Low Energy — wireless protocol used to communicate with external scales |
| **BSP** | British Standard Pipe — thread standard used in espresso machine plumbing fittings |
| **CST816** | Capacitive touch controller IC (Hynitron), I2C interface |
| **EMI** | Electromagnetic Interference — unwanted electrical noise generated by switching circuits |
| **FMEA** | Failure Mode and Effects Analysis — systematic method for evaluating failure scenarios |
| **FreeRTOS** | Real-Time Operating System used on ESP32 for multitasking with priority-based scheduling |
| **GPIO** | General Purpose Input/Output — digital pins on the microcontroller |
| **HAL** | Hardware Abstraction Layer — software interface that decouples logic from specific hardware |
| **ICD** | Interface Control Document — specification defining how two components communicate |
| **ILI9341** | TFT LCD controller IC (Ilitek), SPI interface, drives the 2.8" 320×240 display |
| **ISR** | Interrupt Service Routine — function called by hardware interrupt (e.g., zero-cross detection) |
| **LittleFS** | Lightweight filesystem for embedded flash storage (replaces SPIFFS on ESP32) |
| **LVGL** | Light and Versatile Graphics Library — open-source UI toolkit for embedded displays |
| **MAX31855** | Thermocouple-to-digital converter IC (Analog Devices), SPI interface, reads K-type thermocouples |
| **MISRA C** | Motor Industry Software Reliability Association — coding standard for safety-critical C code |
| **NVS** | Non-Volatile Storage — ESP32's key-value store in flash, used for configuration persistence |
| **OPV** | Over-Pressure Valve — mechanical spring-loaded valve that limits maximum brew pressure (stock: ~12 bar). Adjusted via a set screw inside the valve body (flathead screwdriver; clockwise = higher pressure). Use a portafilter pressure gauge to verify. Recommended: adjust to ~9 bar. |
| **OTA** | Over-The-Air — firmware update mechanism via WiFi, without physical USB connection |
| **PID** | Proportional-Integral-Derivative — control algorithm used for temperature and pressure regulation |
| **PSU** | Power Supply Unit — converts mains AC to low-voltage DC (5V) for electronics |
| **RTOS** | Real-Time Operating System (see FreeRTOS) |
| **SIL** | Safety Integrity Level — IEC 61508 classification of safety function reliability (SIL 1-4) |
| **SPI** | Serial Peripheral Interface — high-speed synchronous serial bus for sensors and display |
| **SSR** | Solid-State Relay — semiconductor switch that controls the boiler heating element (no moving parts) |
| **Triac** | Bidirectional thyristor used in the AC dimmer to control pump power via phase-angle modulation |
| **TWDT** | Task Watchdog Timer — ESP32 hardware watchdog that resets the MCU if not fed periodically |
| **NAN** | IEEE 754 Not-a-Number. Used as a return value from sensor HAL methods to indicate a fault condition (e.g., `readCelsius()` returns NAN when the thermocouple is disconnected). |
| **Phase profiling** | Technique of dividing an espresso shot into discrete phases (pre-infusion, ramp, hold, decline), each with its own pressure or flow target, transition curve, and stop conditions. |
| **Stop condition** | A threshold that triggers the end of a profile phase (phase-level) or the entire shot (global). Examples: time elapsed, pressure above/below, flow above/below, weight reached, volume pumped. Multiple stop conditions can be set; phase advances when ANY is met. |
| **Transition curve** | The mathematical function used to interpolate between a phase's start and end target values. Options: INSTANT (step), LINEAR, EASE_IN (quadratic acceleration), EASE_OUT (quadratic deceleration), EASE_IN_OUT (smoothstep). See algorithm spec in section 9. |
| **Zero-cross detection** | Circuit that detects when AC mains voltage crosses zero, used to synchronize triac firing |

### References

| ID | Document | Relevance |
|----|----------|-----------|
| [R01] | [ESP32-S3 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf) | MCU capabilities, GPIO, SPI, I2C, watchdog, secure boot |
| [R02] | [MAX31855 Datasheet](https://www.analog.com/media/en/technical-documentation/data-sheets/MAX31855.pdf) | Thermocouple interface IC, fault detection bits |
| [R03] | [ADS1115 Datasheet](https://www.ti.com/lit/ds/symlink/ads1115.pdf) | 16-bit ADC for pressure transducer |
| [R04] | [ILI9341 Datasheet](https://cdn-shop.adafruit.com/datasheets/ILI9341.pdf) | TFT display controller, SPI protocol |
| [R05] | [LVGL Documentation](https://docs.lvgl.io/9/) | Embedded UI framework |
| [R06] | [IEC 60335-1:2020](https://webstore.iec.ch/en/publication/61880) | Household appliance safety — general requirements |
| [R07] | [IEC 60335-2-15:2016](https://webstore.iec.ch/en/publication/24667) | Safety — appliances for heating liquids |
| [R08] | [IEC 61508:2010](https://webstore.iec.ch/en/publication/5515) | Functional safety of E/E/PE systems |
| [R09] | [IEEE 29148:2018](https://standards.ieee.org/standard/29148-2018.html) | Requirements engineering |
| [R10] | [Gaggiuino Project](https://github.com/Zer0-bit/gaggiuino) | Prior art and inspiration. No code reused; this is a clean-room design. |
| [R11] | [FreeRTOS API Reference](https://www.freertos.org/a00106.html) | RTOS task, queue, and timer APIs |
| [R12] | [ESPAsyncWebServer](https://github.com/me-no-dev/ESPAsyncWebServer) | Async HTTP/WebSocket server library for ESP32 |
| [R13] | [ESP-IDF FreeRTOS SMP](https://docs.espressif.com/projects/esp-idf/en/stable/esp32s3/api-reference/system/freertos_idf.html) | ESP-IDF's modified FreeRTOS with dual-core (SMP) support |
| [R14] | [CST816 Datasheet](https://www.buydisplay.com/download/ic/DS-CST816S_DS_V1.3.pdf) | Capacitive touch controller IC, I2C interface |
| [R15] | [IEEE 1016-2009](https://standards.ieee.org/standard/1016-2009.html) | Software Design Descriptions |
| [R16] | [JSON Schema 2020-12](https://json-schema.org/draft/2020-12/json-schema-core) | JSON Schema specification used for ICD-05 profile format |
| [R17] | [NimBLE-Arduino](https://github.com/h2zero/NimBLE-Arduino) | Lightweight BLE stack for ESP32 (replaces Bluedroid) |

---

## Table of Contents

1. [Current State: Architecture Overview](#1-current-state-architecture-overview)
2. [Current State: Hardware Topology](#2-current-state-hardware-topology)
3. [Current State: Software Architecture](#3-current-state-software-architecture)
4. [Current State: Communication Protocol](#4-current-state-communication-protocol)
5. [Current State: Configuration & EEPROM](#5-current-state-configuration--eeprom)
6. [Current State: Known Issues](#6-current-state-known-issues)
7. [Future State: Hardware Evaluation](#7-future-state-hardware-evaluation)
8. [Future State: Display & UI Architecture](#8-future-state-display--ui-architecture)
9. [Future State: Software Architecture](#9-future-state-software-architecture)
10. [Future State: Safety Architecture](#10-future-state-safety-architecture)
11. [Future State: Profile Engine](#11-future-state-profile-engine)
12. [Future State: Data Model](#12-future-state-data-model)
13. [Gaggia Classic (Pre-2015) Machine-Specific Notes](#13-gaggia-classic-pre-2015-machine-specific-notes)
14. [Hardware Inventory: Current vs New BOM](#14-hardware-inventory-current-vs-new-bom)
15. [Physical Design: External Electronics Enclosure](#15-physical-design-external-electronics-enclosure)
16. [Requirements Specification](#16-requirements-specification)
17. [Failure Mode and Effects Analysis (FMEA)](#17-failure-mode-and-effects-analysis-fmea)
18. [Verification & Test Plan](#18-verification--test-plan)
19. [Standards Review & Gap Analysis](#19-standards-review--gap-analysis)
20. [Interface Control Documents & APIs](#20-interface-control-documents--apis)
21. [Decisions & Open Questions](#21-decisions--open-questions)

**How to read this document:** Sections 1-6 analyze the current (legacy) architecture. Sections 7-15 define the future state design (hardware, software, safety, UI). Section 16 contains formal requirements, section 17 is the FMEA, section 18 is the test plan. Section 19 is the standards gap analysis. Section 20 defines all interface contracts (APIs, HALs, schemas). Section 21 tracks decisions and open questions.

---

## 1. Current State: Architecture Overview

The current Gaggiuino system uses a **dual-MCU architecture**:

```
┌─────────────────────┐         UART (115200)         ┌─────────────────────┐
│     STM32F411CE     │◄──────────────────────────────►│  ESP32-S2/S3 (Lego) │
│  "Blackpill" MCU    │                                │   UI + Networking    │
│                     │                                │                     │
│  - PID control      │                                │  - Nextion display   │
│  - Sensor reading   │                                │  - BLE scales comm   │
│  - Pump (dimmer)    │                                │  - EEPROM storage    │
│  - Solenoid valve   │                                │  - Profile storage   │
│  - Boiler SSR       │                                │  - Web OTA           │
│  - Pressure sensor  │                                │                     │
│  - Thermocouple     │                                │                     │
│  - Flow sensor      │                                │                     │
└─────────────────────┘                                └─────────────────────┘
```

**Why dual MCU:** The STM32 handles deterministic real-time control (PID, zero-cross dimmer timing, sensor polling) while the ESP32 handles WiFi/BLE connectivity, display rendering, and persistent storage. This split exists because the original design predates the ESP32-S3 which can handle both roles.

### Build System

- **PlatformIO** with custom build environments
- Three build targets: `lego-stm32`, `lego-esp32s2`, `lego-esp32s3`
- Shared code in `lib/Common/` (compiled by both MCUs)
- MCU-specific code gated by `#if defined(ESP32S2)` / `#if defined(ESP32S3)` preprocessor guards

---

## 2. Current State: Hardware Topology

### Sensors

| Sensor | Interface | Purpose | Read Rate |
|--------|-----------|---------|-----------|
| Thermocouple (MAX31855) | SPI | Boiler temperature | ~100ms (MAX31855 conversion time) |
| Pressure transducer | Analog (ADS1115 ADC) | Brew pressure (0-12 bar range) | ~50ms |
| Flow sensor (hall-effect) | GPIO interrupt | Water flow / volume | Pulse counting |
| Weight (BLE scales) | BLE via ESP32 | Cup weight | ~100ms (variable) |

### Actuators

| Actuator | Control Method | Purpose |
|----------|---------------|---------|
| Boiler SSR | GPIO (bang-bang via PID) | Temperature control |
| Pump (dimmer) | Zero-cross phase-angle dimming | Pressure/flow control |
| Solenoid valve | GPIO | 3-way valve (brew/backflush) |

### Dimmer Control (Phase-Angle)

The pump is driven by a **zero-cross detection + phase-angle dimming** circuit (`SystemComponents::setPumpPower()`). The dimmer uses a triac and zero-cross detector. Power levels are set as a percentage (0-100%) mapped to phase-angle timing. This is the most timing-critical component in the system.

---

## 3. Current State: Software Architecture

### STM32 Side (Real-Time Control)

```
Main Loop (gaggiuino.cpp)
│
├── sensorsRead()           # Poll all sensors via ADS1115
│   ├── Temperature         # MAX31855 thermocouple
│   ├── Pressure            # Analog transducer (0-12 bar)
│   └── Flow                # Hall-effect pulse counter
│
├── lcdRefresh()            # Send sensor state to ESP32 via UART
│
├── systemHealthCheck()     # Monitor for faults (thermocouple, pressure)
│   ├── Thermocouple fault detection
│   └── Pressure sensor fault detection
│
└── State Machine:
    ├── BREW_MODE_4 (espresso_profiling)
    │   ├── PhaseProfiler    # Multi-phase profile engine
    │   ├── PID (pressure)   # Pressure PID controller
    │   ├── PID (flow)       # Flow PID controller
    │   └── PredictiveWeight # Estimate weight without scales
    │
    ├── FLUSH_MODE (backflushing)
    │
    ├── DESCALE_MODE (descaling)
    │
    └── STEAM_MODE (steam control)
        └── PID (temperature) for steam setpoint
```

### ESP32 Side (UI + Connectivity)

```
Main Loop (esp_comms.cpp)
│
├── UART receive/transmit    # Communication with STM32
│
├── Display (Nextion)        # Touch display protocol
│   ├── Page navigation
│   ├── Profile editing UI
│   └── Shot graph rendering
│
├── BLE Scales               # Bluetooth Low Energy
│   ├── Acaia
│   ├── Felicita
│   ├── Decent
│   └── Bookoo (multiple models)
│
├── EEPROM Management        # Persistent configuration
│   └── eepromValues_t struct (entire config blob)
│
└── Web OTA                  # Over-the-air firmware update
```

### PID Controllers

The system uses **four separate PID instances** (`PidController` class):

1. **Brew temperature PID** — controls boiler SSR during brewing
2. **Steam temperature PID** — controls boiler SSR during steaming
3. **Pressure PID** — controls pump dimmer level during profiled shots
4. **Flow PID** — controls pump dimmer level when profiling by flow

The PID implementation is in `lib/Common/pid.h`. It is a basic P-I-D with:
- Configurable gains (Kp, Ki, Kd)
- Windback (anti-windup via integral clamping)
- Output clamping (0-100% for pump, 0-100% for SSR duty)
- Division-by-zero guard on Kp

Notable: The "flow PID" operates as a **cascaded controller** — it computes a pressure setpoint from flow error, then the pump targets that pressure. This is done by assigning the flow PID output as the pressure setpoint.

### Profile Engine

The profile engine (`PhaseProfiler` class) implements a **multi-phase shot profile**:

```
Profile
├── Phase 0: Pre-infusion (pressure or flow target)
│   ├── Target transition (instant, linear, ease-in, ease-out, ease-in-out)
│   ├── Stop conditions (time, pressure threshold, flow threshold, weight)
│   └── Restriction (max flow or max pressure)
│
├── Phase 1: Soak (optional hold/dwell phase)
│   └── Same structure as above
│
├── Phase 2: Ramp to extraction pressure
│   └── Transition from soak pressure to brew pressure
│
├── Phase N: ... (variable number of phases)
│
└── Global Stop Conditions
    ├── Total time limit
    ├── Total weight limit
    └── Total water pumped limit
```

Each phase can be either `PHASE_TYPE_PRESSURE` or `PHASE_TYPE_FLOW`, with a target value that transitions according to a curve. Phases advance automatically when their stop conditions are met.

### Predictive Weight

`PredictiveWeight` estimates when liquid output begins (without physical scales) by:
1. Monitoring puck resistance (pressure / flow ratio)
2. Tracking pressure drop patterns
3. Using empirical thresholds (2.1 bar = headspace full, puck resistance > 1100 mbar·s/g where resistance = pressure / flow rate)
4. Force-starting after 65ml pumped

This allows dose-by-weight functionality even without BLE scales connected.

---

## 4. Current State: Communication Protocol

### UART Protocol (STM32 ↔ ESP32)

- **Baud rate:** 115200
- **Format:** Binary packets with markers
- **Library:** Custom `McuComms` class wrapping the `transfer` library
- **Packet types:** 12+ distinct message types

| Message Type | Direction | Payload |
|-------------|-----------|---------|
| `SensorStateSnapshot` | STM32 → ESP32 | Temperature, pressure, flow, weight, pump clicks, state |
| `Profile` | ESP32 → STM32 | Full shot profile (phases, transitions, stop conditions) |
| `ShotSnapshot` | STM32 → ESP32 | Real-time shot data for graphing |
| `SystemState` | Both directions | Operational mode, tarring, settings update flags |
| `RemoteScalesWeight` | ESP32 → STM32 | BLE scale reading |
| `Notification` | STM32 → ESP32 | Toast notifications to display |

### Nextion Display Protocol

The ESP32 communicates with the Nextion display via UART using the Nextion instruction set:
- Commands terminated with `0xFF 0xFF 0xFF`
- Numeric values via `page.component.val=N`
- String values via `page.component.txt="string"`
- Touch events received as binary packets

### BLE Scales Protocol

Supports multiple scale brands via a unified `RemoteScales` abstraction:
- **Acaia:** Lunar, Pearl, Pyxis (proprietary BLE protocol with heartbeat)
- **Felicita:** Arc (standard weight characteristic)
- **Decent:** DE1 scale (custom protocol)
- **Bookoo:** MiniScale, Theme (custom BLE services)

Each implementation handles: connection, weight reading, taring, and heartbeat/keepalive.

---

## 5. Current State: Configuration & EEPROM

### eepromValues_t Structure

The entire system configuration is stored in a single flat struct (`eepromValues_t`) that is:
- Written to ESP32 flash as a binary blob
- Transmitted over UART to STM32 on boot and on changes
- ~200+ fields covering all settings

Key sections:
```
eepromValues_t
├── System settings
│   ├── lcdSleep (display timeout)
│   ├── warmupState (enable warmup mode)
│   ├── brewDeltaState (temperature compensation during brew)
│   └── scalesF1/F2 (scale calibration factors)
│
├── Boiler PID tuning
│   ├── steamSetPoint, offsetTemp
│   ├── hpwr, mainDivider, brewDivider (PID gains - obfuscated names)
│   └── kProportional, kIntegral, kDerivative (newer named gains)
│
├── Profile settings (×5 profiles)
│   ├── preinfusionState, preinfusionBar, preinfusionFlowState
│   ├── soakState, soakTimePressure, soakTimeFlow, soakKeepPressure
│   ├── hotWaterFlowState (for flow-profiled extraction)
│   ├── preinfusionFlowVol, preinfusionFlowPressureTarget
│   ├── tfProfileStart, tfProfileEnd, tfProfileHold, tfProfileSteep
│   │   (temperature profiling at different shot phases)
│   ├── profilingState (enable multi-phase profiling)
│   ├── phases[] (array of phase configurations)
│   └── globalStopConditions (time, weight, volume limits)
│
└── Versioning
    ├── versionId (schema version for migration)
    └── EEPROM_DATA_VERSION (compile-time version)
```

### Profile Storage

Profiles are stored as part of the EEPROM struct. Up to 5 profiles, each with:
- Pre-infusion settings (pressure or flow mode)
- Soak/dwell settings
- Extraction phase settings
- Temperature profiling per phase
- Global stop conditions (weight, time, volume)

---

## 6. Current State: Known Issues

These are architectural and code-quality issues identified through code review:

### Critical Safety Issues

1. **No watchdog timer** — If the main loop hangs, the boiler SSR stays in its last state. A stuck-on SSR with no watchdog = uncontrolled heating.

2. **Temperature fault handling is incomplete** — `systemHealthCheck()` detects thermocouple faults but the recovery path is unclear. The system should enter a hard fail-safe (all outputs off) on any temperature sensor failure.

3. **No boiler dry-fire protection** — There is no logic to detect an empty boiler. If the machine runs without water, the heating element will overheat.

### Architectural Issues

4. **Massive flat config struct** — `eepromValues_t` is a single monolithic struct with 200+ fields, many with cryptic names (`hpwr`, `mainDivider`, `brewDivider`). No schema validation. Binary-blob serialization means any struct change breaks all saved configs.

5. **Tight coupling between MCUs** — The STM32 and ESP32 share header files and must be flashed together. Version skew between the two causes undefined behavior.

6. **Global mutable state** — Extensive use of global variables, especially in `gaggiuino.cpp` and `predictive_weight.h`. The `PredictiveWeight` header file defines global variables (`predictiveTargetReached`, `predictivePreinfusionFinishedCheck`) that will cause multiple-definition errors if included from more than one translation unit.

7. **No unit tests** — The `test/` directory is empty. PID tuning, profile phase transitions, and predictive weight logic have zero test coverage.

8. **Inconsistent naming** — Mix of `camelCase`, `snake_case`, Hungarian notation, and abbreviations. Profile fields use opaque names (`tfProfileStart` = temperature profile at start, `hpwr` = heater power? PID high power?).

### Protocol Issues

9. **UART protocol has no CRC or error correction** — The `McuComms` layer uses start/end markers but no checksum. Corrupted bytes between the MCUs could cause misinterpreted commands (e.g., a corrupted pump power value).

10. **No protocol versioning** — If the UART message format changes between firmware versions, there is no negotiation or version check. Flashing one MCU without the other causes silent failures.

### Code Quality Issues

11. **Header files with implementation** — Multiple `.h` files contain full method implementations and global variable definitions (e.g., `predictive_weight.h`, `scales_handler.h`). This breaks the one-definition rule if headers are included in multiple translation units.

12. **Magic numbers throughout** — Thresholds like `2.1f` (pressure), `1100.f` (resistance), `65.f` (ml pumped), `500.f` (resistance delta) are hardcoded without named constants or documentation of their empirical derivation.

13. **EEPROM migration is fragile** — `eeprom_data.cpp` has version-specific migration code, but adding or removing a field requires careful manual migration logic. There is no schema hash or field-level versioning.

---

## 7. Future State: Hardware Evaluation

### Option A: Single MCU — ESP32-S3

```
┌─────────────────────────────────────────────┐
│                ESP32-S3-WROOM-1              │
│                                              │
│  Core 0 (Real-Time)     Core 1 (App)        │
│  ├── PID loop           ├── WiFi/BLE        │
│  ├── Dimmer timing      ├── Display          │
│  ├── Sensor polling     ├── Web server       │
│  └── Safety watchdog    └── OTA updates      │
│                                              │
│  Peripherals:                                │
│  ├── SPI: Thermocouple (MAX31855)            │
│  ├── I2C: ADC (ADS1115) for pressure        │
│  ├── GPIO: Dimmer (zero-cross + triac)       │
│  ├── GPIO: SSR (boiler)                      │
│  ├── GPIO: Solenoid valve                    │
│  ├── GPIO: Flow sensor (interrupt)           │
│  ├── BLE: Scales communication               │
│  └── SPI/I2C/Parallel: Display               │
└─────────────────────────────────────────────┘
```

**Pros:**
- Single firmware image, no UART protocol, no version-skew issues
- ESP32-S3 dual-core 240MHz is powerful enough for PID + UI
- Simpler BOM, fewer connectors, lower cost
- WiFi + BLE native
- Well-supported by ESP-IDF and Arduino framework

**Cons:**
- Real-time guarantees weaker than STM32 (WiFi interrupts can preempt)
- Must carefully pin Core 0 for real-time tasks and Core 1 for networking
- Analog peripherals are weaker than STM32 (still need external ADC)
- Single point of failure — if the MCU crashes, everything stops

**Mitigation for real-time concerns:**
- Use FreeRTOS task pinning: PID/dimmer on Core 0 with highest priority
- Hardware timer interrupts for zero-cross detection (not affected by WiFi)
- Watchdog timer on the real-time core

### Option B: Keep Dual MCU (STM32 + ESP32)

**Pros:**
- Proven architecture, already working
- True hardware isolation between safety-critical and UI code
- STM32 has deterministic interrupt timing

**Cons:**
- UART protocol complexity and failure modes
- Two firmware images to maintain and flash
- Higher BOM cost and board complexity
- Version-skew risk between MCUs

### Option C: RP2040 + ESP32-S3

**Pros:**
- RP2040 PIO state machines give deterministic I/O timing
- Cheap ($1 for RP2040)
- ESP32-S3 handles WiFi/BLE/display

**Cons:**
- Still dual-MCU with all the protocol complexity
- RP2040 ecosystem less mature for this use case
- No clear advantage over Option A for this application

### Option D: ESP32-P4 + ESP32-C6 (Future Upgrade Path)

The ESP32-P4 is Espressif's HMI-oriented SoC: dual-core RISC-V at 400MHz, MIPI-DSI display interface (up to 1080p), hardware H.264 encoder, up to 32MB PSRAM. No built-in WiFi/BLE — requires a companion ESP32-C6 or C5 for wireless.

Waveshare sells ready-made dev boards with 7/8/10.1" IPS capacitive touchscreens and ESP32-C6 integrated.

**Pros:**
- Gorgeous large display, tablet-class graphics performance
- Hardware-accelerated rendering (PPA, 2D-DMA)
- Enough power for everything on one platform

**Cons:**
- Still dual-chip (P4 + C6), though on the same PCB module
- Requires custom enclosure to mount 7"+ display on Gaggia Classic
- ~$40-80 for board + display vs ~$8 for ESP32-S3 + TFT
- ESP32-P4 ecosystem is newer and less battle-tested
- Overkill for PID + pump control

**Best for:** Future upgrade if a premium built-in display is desired after prototyping.

### Option E: RP2350 (Pico 2 W)

Dual-core ARM Cortex-M33 at 150MHz, WiFi + BLE 5.2, 520KB RAM, 3 PIO blocks (12 state machines for deterministic I/O). ~$7.

**Pros:**
- PIO state machines are ideal for zero-cross dimmer timing (hardware-level determinism)
- WiFi + BLE built in
- Cheap

**Cons:**
- 150MHz is adequate but not generous
- Pico 2 W has no onboard PSRAM (RP2350 chip supports external PSRAM via QMI, but the board does not include it)
- Arduino/ESP-IDF ecosystem is more mature for this use case
- Fewer community libraries for BLE scales, LVGL display, etc.

**Best for:** Only if ESP32-S3 dimmer jitter proves to be a real problem (PIO solves it definitively).

### Recommendation

**Option A (ESP32-S3 single MCU) is the recommended starting point for evaluation.** The Gaggia Classic control requirements (PID at 50-100Hz, zero-cross dimmer, sensor polling) are well within the ESP32-S3's capabilities when using proper RTOS task pinning. The elimination of the UART protocol removes an entire class of bugs. A hardware watchdog timer addresses the single-point-of-failure concern.

If evaluation reveals that WiFi/BLE activity causes unacceptable jitter in PID or dimmer timing, fall back to Option B. If a premium display is desired later, evaluate Option D (ESP32-P4).

---

## 8. Future State: Display & UI Architecture

### Decision: SPI TFT (2.8") + Web App

**Status: DECIDED** — Start with the cheapest option that doesn't close any doors. Evaluate during prototyping whether to upgrade.

```
┌───────────────────────────────────────────────────────────────┐
│                        ESP32-S3                                │
│                                                                │
│  ┌─────────────┐    SPI     ┌──────────────────────────────┐  │
│  │ Control     │            │  ILI9341 2.8" TFT (320×240)  │  │
│  │ (Core 0)    │            │  + Capacitive touch (CST816)  │  │
│  └─────────────┘            │                               │  │
│                              │  Shows during shot:           │  │
│  ┌─────────────┐            │  ├── Temperature (current/set) │  │
│  │ UI + Web    │───────────►│  ├── Pressure graph (live)     │  │
│  │ (Core 1)    │            │  ├── Flow rate                 │  │
│  └──────┬──────┘            │  ├── Shot timer                │  │
│         │                    │  ├── Weight (if scales)        │  │
│         │                    │  └── Phase indicator           │  │
│         │  WiFi              │                               │  │
│         │  HTTP + WebSocket  │  Shows at idle:                │  │
│         │                    │  ├── Current temperature       │  │
│         ▼                    │  ├── Ready/heating status      │  │
│  ┌─────────────┐            │  └── Active profile name       │  │
│  │  Web App    │            └──────────────────────────────┘  │
│  │  (LittleFS) │                                               │
│  └─────────────┘                                               │
│         │                                                      │
│         ▼                                                      │
│  Phone / Tablet / Laptop (any browser on home WiFi)            │
│  ├── Profile editor (create, modify, import/export)            │
│  ├── Shot history with detailed graphs                         │
│  ├── PID tuning interface                                      │
│  ├── System settings (WiFi, scales, display)                   │
│  ├── Real-time shot monitoring (WebSocket)                     │
│  └── OTA firmware update                                       │
└───────────────────────────────────────────────────────────────┘
```

### Why This Approach

This is a home-only machine on a stable WiFi network, so connectivity is not a concern. The key uncertainty is whether a 2.8" TFT is enough at the machine, or whether a phone/web UI is sufficient on its own. Starting with both — cheap TFT + web app — lets us find out.

**Total display hardware cost: ~$5**

### Machine-Mounted Display: ILI9341 2.8" TFT

| Spec | Value |
|------|-------|
| Controller | ILI9341 |
| Resolution | 320×240 (QVGA) |
| Size | 2.8" diagonal |
| Interface | SPI (ESP32-S3 supports up to 80MHz; ILI9341 typically runs at 26-40MHz write clock) |
| Touch | CST816 capacitive (I2C) or XPT2046 resistive (SPI) |
| Cost | ~$5 |
| UI Framework | LVGL v9 (C, open source) |

What it shows:
- **Idle screen:** Temperature (large font, readable at arm's length), heating progress bar, ready indicator, active profile name
- **Shot screen:** Real-time pressure/flow graph, shot timer, weight, phase indicator, target vs actual overlays
- **Minimal touch:** Start/stop (physical switch preferred), profile select (swipe or tap), tare scales
- **Profile quick-select:** TFT shows up to 5 favorite profiles for fast switching. Full list available via web app. This satisfies REQ-U-003 (≤ 3 taps from idle) even with many saved profiles.

**Physical switch vs. remote control priority:**
The Gaggia's physical brew switch is wired to a GPIO input and acts as the **primary authority**:
- Physical switch ON → shot starts (regardless of software state)
- Physical switch OFF → shot stops immediately (overrides any WebSocket `start_shot` command)
- WebSocket `start_shot` → only honored if physical switch is already ON (switch acts as a hardware enable gate)
- This means the physical switch is a hardware-level safety interlock: turning it off always stops the shot.

What it does NOT show (use web app instead):
- Profile editor (too complex for 320×240)
- PID tuning
- Shot history
- System settings

### Web App

| Spec | Value |
|------|-------|
| Server | ESP32 AsyncWebServer (Core 1) |
| Real-time | WebSocket (~20-50ms latency on LAN) |
| Storage | LittleFS partition (2-4MB for web assets) |
| Framework | TBD — Svelte or Preact (small bundle, good DX) |
| Auth | Read-only endpoints: none (open). Write/command endpoints: session token required (see below). OTA/restart/factory-reset: OTA password required. |

Pages:
- **Dashboard:** Live shot view (mirrors TFT but with larger, richer graphs)
- **Profiles:** Full profile editor — phase list, transition curves, stop conditions, temperature targets. Visual preview of the profile curve.
- **History:** Shot log with overlay comparison, export to CSV/JSON
- **Settings:** PID tuning with live response graph, WiFi config, BLE scales pairing, display settings
- **Update:** OTA firmware upload

### API Design (WebSocket + REST)

The web app communicates with the ESP32 via two channels:

**REST API** (for CRUD operations):
```
GET    /api/profiles              # List all profiles
GET    /api/profiles/:id          # Get single profile
POST   /api/profiles              # Create profile
PUT    /api/profiles/:id          # Update profile
DELETE /api/profiles/:id          # Delete profile
GET    /api/config                # Get system config
PUT    /api/config                # Update system config
GET    /api/shots                 # List shot history
GET    /api/shots/:id             # Get shot detail with datapoints
POST   /api/ota                   # Upload firmware binary
```

**WebSocket** (`ws://<ip>/ws`) for real-time data:
```json
// Server → Client: sensor data (every 100ms during shot)
{"type": "shot_data", "t": 12300, "temp": 93.1, "pressure": 8.7,
 "flow": 2.1, "weight": 24.3, "target_p": 9.0, "target_f": -1, "phase": 2}

// Server → Client: state changes
{"type": "state", "mode": "brewing", "ready": true, "temp": 93.0}

// Client → Server: commands
{"type": "command", "action": "tare_scales"}
{"type": "command", "action": "set_active_profile", "id": 3}
```

This same WebSocket API is what a future iOS/native app would connect to — so building the web app first doesn't lock out native apps later.

### Upgrade Paths (Evaluate During Prototyping)

After living with the prototype, these are the questions and corresponding upgrades:

| Question | If Yes | Upgrade To |
|----------|--------|------------|
| Is 2.8" too small to read during a shot? | Rarely look at it | Larger 3.5" ILI9488 (480×320), same SPI interface, same LVGL code. ~$8 |
| Do I never look at the machine display? | Always use phone | Drop the TFT entirely. Save the SPI bus and CPU cycles. |
| Is the web app too clunky for daily use? | Want native feel | Build iOS app connecting to the same WebSocket/REST API. Web app still works for others. **Note:** iOS App Transport Security blocks plain HTTP/WS by default. A native iOS app requires either HTTPS/WSS on the ESP32, or a Bonjour/`.local` ATS exception. |
| Do I want a premium built-in display? | Want tablet-on-machine | Move to ESP32-P4 + 7" MIPI-DSI. Different MCU, bigger project. |
| Is the web app latency noticeable? | Shots feel laggy on phone | Acceptable — this is monitoring, not control. The TFT runs from local data with zero latency. |

### Options Considered and Rejected

| Option | Why Rejected |
|--------|-------------|
| **Nextion display** | Proprietary, vendor lock-in, UART bottleneck, dated UI, Windows-only editor |
| **OLED 128×64** | Too small for a pressure graph — can only show text. If we're mounting a display, the TFT is $3 more and far more useful |
| **No machine display** | Reasonable but untested — we don't know yet if reaching for a phone every shot is annoying. The $5 TFT hedges this bet |
| **ESP32-P4 + 7" MIPI** | Overkill for a prototype. Different MCU. Custom enclosure needed. Evaluate later if the 2.8" proves insufficient |
| **Native iOS app (now)** | High effort, platform lock-in. Build the WebSocket API first, add native app later if the web app isn't enough |

---

## 9. Future State: Software Architecture

### Core Principles

1. **Single firmware image** (assuming ESP32-S3 single MCU)
2. **FreeRTOS tasks with strict core affinity** — real-time on Core 0, everything else on Core 1
3. **Message-passing between tasks** (FreeRTOS queues, not shared globals)
4. **Testable** — core logic (PID, profiles, predictive weight) in pure C++ with no hardware dependencies
5. **Safe by default** — watchdog, fail-safe states, validated inputs

### Task Architecture

```
┌─────────────────────────── ESP32-S3 ───────────────────────────┐
│                                                                 │
│  Core 0 (Real-Time, pinned)          Core 1 (Application)      │
│  ┌─────────────────────┐             ┌──────────────────────┐  │
│  │  ControlTask (5ms)  │             │  UITask (50ms)       │  │
│  │  ├── Read sensors   │  Queues     │  ├── Web server      │  │
│  │  ├── Run PID        │◄──────────► │  ├── WebSocket push  │  │
│  │  ├── Set pump power │             │  ├── Display update   │  │
│  │  ├── Set SSR        │             │  └── Profile editor   │  │
│  │  └── Safety checks  │             └──────────────────────┘  │
│  └─────────────────────┘                                        │
│  ┌─────────────────────┐             ┌──────────────────────┐  │
│  │  DimmerISR          │             │  BLETask             │  │
│  │  (hardware timer)   │             │  ├── Scale reading    │  │
│  │  └── Zero-cross +   │             │  └── Heartbeat mgmt  │  │
│  │      phase-angle    │             └──────────────────────┘  │
│  └─────────────────────┘                                        │
│  ┌─────────────────────┐             ┌──────────────────────┐  │
│  │  WatchdogTask       │             │  PersistenceTask     │  │
│  │  └── Feed or reset  │             │  ├── Config save     │  │
│  └─────────────────────┘             │  └── Shot logging    │  │
│                                       └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### Module Decomposition

**PlatformIO note:** PlatformIO compiles `src/` recursively by default when using the Arduino framework, but some configurations require explicit `build_src_filter`. If subdirectories are not compiled, add to `platformio.ini`: `build_src_filter = +<*> +<**/*.cpp>`. Alternatively, organize modules as PlatformIO library components under `lib/` (each with its own `library.json`).

```
src/
├── main.cpp                    # App entry, task creation
├── control/
│   ├── control_task.h/cpp      # Main real-time control loop
│   ├── pid.h/cpp               # PID controller (pure math, testable)
│   ├── dimmer.h/cpp            # Zero-cross phase-angle dimmer driver
│   ├── boiler.h/cpp            # SSR control with safety limits
│   └── state_machine.h/cpp     # Brew/steam/idle/flush states
│
├── sensors/
│   ├── sensor_manager.h/cpp    # Unified sensor reading interface
│   ├── thermocouple.h/cpp      # MAX31855 driver
│   ├── pressure.h/cpp          # ADS1115-based pressure transducer
│   └── flow.h/cpp              # Hall-effect flow sensor (ISR-based)
│
├── profile/
│   ├── profile.h/cpp           # Profile data structures
│   ├── phase_profiler.h/cpp    # Phase engine (pure logic, testable)
│   └── predictive_weight.h/cpp # Weight estimation (pure logic, testable)
│
├── ui/
│   ├── display.h/cpp           # Small status display driver (OLED/TFT)
│   ├── web_server.h/cpp        # HTTP server + static file serving
│   └── websocket.h/cpp         # Real-time shot data streaming
│
├── connectivity/
│   ├── ble_scales.h/cpp        # BLE scale abstraction
│   ├── wifi_manager.h/cpp      # WiFi connection management
│   └── ota.h/cpp               # Over-the-air firmware updates
│
├── config/
│   ├── config.h/cpp            # Configuration schema (typed, validated)
│   ├── storage.h/cpp           # NVS/LittleFS persistence
│   └── migration.h/cpp         # Config version migration
│
├── safety/
│   ├── watchdog.h/cpp          # Hardware watchdog management
│   ├── fault_handler.h/cpp     # Centralized fault detection/response
│   └── safety_limits.h         # Compile-time safety constants
│
└── test/
    ├── test_pid.cpp
    ├── test_phase_profiler.cpp
    ├── test_predictive_weight.cpp
    ├── test_config_migration.cpp
    └── test_state_machine.cpp
```

### Inter-Task Communication

```
                    ┌────────────────────┐
                    │   SensorReading    │
                    │   {temp, pressure, │
ControlTask ──────► │    flow, weight}   │ ──────► UITask
  produces          └────────────────────┘         consumes
                                                   (for display/WS)

                    ┌────────────────────┐
                    │   ShotDataPoint    │
                    │   {time, pressure, │
ControlTask ──────► │    flow, weight,   │ ──────► UITask
  produces          │    target_p, ...}  │         consumes
                    └────────────────────┘         (for shot graph)

                    ┌────────────────────┐
                    │   ConfigUpdate     │
                    │   {new profile,    │
UITask ────────────►│    new settings}   │ ──────► ControlTask
  produces          └────────────────────┘         consumes
                                                   (applies changes)

                    ┌────────────────────┐
                    │   ScaleReading     │
                    │   {weight, stable} │
BLETask ───────────►└────────────────────┘ ──────► ControlTask
  produces                                         consumes
```

All communication uses **FreeRTOS queues** with bounded sizes. If a queue is full, the producer drops the oldest item (for telemetry) or blocks briefly (for commands). No shared mutable state between tasks.

**IPC mechanism rationale:** FreeRTOS queues were chosen over event groups (cannot carry data), task notifications (single producer/consumer only), and stream buffers (byte-oriented, not message-oriented). Queues provide bounded, typed, thread-safe message passing with optional blocking, which matches the producer-consumer pattern between all tasks.

### System Context Diagram

```
                            ┌───────────────────────────────────┐
                            │     Open Espresso Firmware        │
     ┌──────────┐           │         (ESP32-S3)                │          ┌──────────────┐
     │  Gaggia  │           │                                   │          │   Browser /  │
     │  Classic │◄──sensors─┤  Sensors ──► Control ──► Safety   │──WiFi───►│   Phone      │
     │ (Machine)│──actuators┤               │   │               │  REST/WS │   (Web App)  │
     │          │           │  Display ◄────┘   └──► Persist    │          └──────────────┘
     └────┬─────┘           │                                   │
          │                 │  BLE ◄─────────────────────────── │ ◄──BLE──── ┌────────────┐
     Mains AC               │                                   │            │ BLE Scales │
     (230V/120V)            └───────────────────────────────────┘            └────────────┘
                                          │
                              ┌───────────┴───────────┐
                              │  External Libraries   │
                              │  FreeRTOS, LVGL,      │
                              │  ESPAsyncWebServer,   │
                              │  NimBLE, LittleFS     │
                              └───────────────────────┘
```

Data flows crossing the system boundary:
- **Sensors (in):** Temperature (SPI/MAX31855), pressure (I2C/ADS1115), flow (GPIO/ISR)
- **Actuators (out):** SSR (GPIO), dimmer gate (GPIO), solenoid (GPIO)
- **User input (in):** Brew switch (GPIO), steam switch (GPIO), TFT touch (I2C), web commands (WiFi/WS)
- **Display (out):** TFT (SPI), web app (WiFi/HTTP+WS)
- **BLE (in):** Weight from external scales
- **Persistence (internal):** NVS (config), LittleFS (profiles, shot logs, web assets)

### Module Annotations

| Module | RTOS Task | Pure Logic? | Dependencies |
|--------|-----------|-------------|-------------|
| `control/control_task` | ControlTask (Core 0) | No (reads sensors, writes actuators) | sensors/sensor_manager, control/pid, control/dimmer, control/boiler, control/state_machine, profile/phase_profiler, profile/predictive_weight, safety/fault_handler, safety/watchdog |
| `control/pid` | ControlTask | **Yes** (testable on host) | None |
| `control/dimmer` | ControlTask + DimmerISR | No (hardware timer, GPIO) | None |
| `control/boiler` | ControlTask | No (GPIO) | safety/safety_limits |
| `control/state_machine` | ControlTask | **Yes** (testable on host) | None |
| `sensors/sensor_manager` | ControlTask | No (I2C, SPI, GPIO) | sensors/thermocouple, sensors/pressure, sensors/flow |
| `sensors/thermocouple` | ControlTask | No (SPI) | None (implements TemperatureSensor HAL) |
| `sensors/pressure` | ControlTask | No (I2C) | None (implements PressureSensor HAL) |
| `sensors/flow` | ControlTask (ISR) | No (GPIO interrupt) | None (implements FlowSensor HAL) |
| `profile/phase_profiler` | ControlTask | **Yes** (testable on host) | profile/profile |
| `profile/predictive_weight` | ControlTask | **Yes** (testable on host) | None |
| `profile/profile` | Shared (data struct) | **Yes** | None |
| `ui/display` | UITask (Core 1) | No (SPI, LVGL) | LVGL |
| `ui/web_server` | UITask (Core 1) | No (WiFi) | ESPAsyncWebServer, config/storage |
| `ui/websocket` | UITask (Core 1) | No (WiFi) | ESPAsyncWebServer |
| `connectivity/ble_scales` | BLETask (Core 1) | No (BLE) | NimBLE |
| `connectivity/wifi_manager` | UITask (Core 1) | No (WiFi) | ESP-IDF WiFi |
| `connectivity/ota` | UITask (Core 1) | No (flash) | ESP-IDF OTA |
| `config/config` | Shared (data struct) | **Yes** | None |
| `config/storage` | PersistenceTask (Core 1) | No (NVS, LittleFS) | LittleFS |
| `config/migration` | PersistenceTask | **Yes** (testable on host) | config/config |
| `safety/watchdog` | WatchdogTask (Core 0) | No (TWDT hardware) | None |
| `safety/fault_handler` | ControlTask | **Yes** (logic testable) | safety/safety_limits |
| `safety/safety_limits` | Compile-time only | **Yes** (header only) | None |

### RTOS Task Configuration

| Task | Core | Priority | Stack Size | Period / Trigger | Watchdog | Creates Queues |
|------|------|----------|------------|-----------------|----------|----------------|
| **ControlTask** | 0 (pinned) | 24 (highest app) | 8192 bytes | 5ms (200Hz timer) | Feeds TWDT every iteration | SensorReading, ShotDataPoint |
| **DimmerISR** | 0 | N/A (ISR) | N/A | Zero-cross GPIO interrupt | N/A | N/A |
| **WatchdogTask** | 0 (pinned) | 25 (above control) | 2048 bytes | 100ms | Is the watchdog manager | N/A |
| **UITask** | 1 (pinned) | 10 | 16384 bytes | 50ms (20 Hz display) | Not monitored (non-safety) | Command, ConfigUpdate |
| **BLETask** | 1 | 8 | 8192 bytes | Event-driven (BLE callbacks) | Not monitored | ScaleReading |
| **PersistenceTask** | 1 | 5 (lowest) | 4096 bytes | Event-driven (queue) | Not monitored | N/A (consumes ShotDataPoint) |

**Priority rationale:** ControlTask must never be preempted by UI or BLE work. WatchdogTask is higher priority so it can always check ControlTask health. UITask, BLETask, and PersistenceTask are non-safety and run on Core 1 where WiFi/BLE stacks also reside.

**Stack size rationale:** UITask needs 16KB for LVGL rendering buffers and web server response construction. ControlTask needs 8KB for PID computation, profile engine, and sensor reading. BLETask needs 8KB for NimBLE stack. PersistenceTask and WatchdogTask are lightweight.

**ISR latency budget:** The zero-cross detection ISR must fire within 100µs of the zero-cross event to maintain < 1% phase-angle error at 50Hz. The ISR body must complete in < 10µs (set a flag and return). The actual triac firing is handled by a hardware timer started from the ISR.

### Third-Party Library Dependencies

| Library | Version | License | Purpose |
|---------|---------|---------|---------|
| ESP-IDF | ≥ 5.1 | Apache 2.0 | Base framework (WiFi, BLE, SPI, I2C, NVS, OTA, FreeRTOS) |
| LVGL | 9.x | MIT | TFT display UI rendering |
| ESPAsyncWebServer | 3.x | LGPL-3.0 | Async HTTP/WebSocket server |
| AsyncTCP | 3.x | LGPL-3.0 | TCP layer for ESPAsyncWebServer |
| NimBLE-Arduino | 1.4+ | Apache 2.0 | BLE stack (lighter than default Bluedroid) |
| LittleFS | (bundled with ESP-IDF) | BSD-3 | Flash filesystem for profiles, shots, web assets |
| ArduinoJson | 7.x | MIT | JSON parsing/serialization for REST API and profile files |

**License compatibility:** All libraries are compatible with open-source distribution. LGPL-3.0 (ESPAsyncWebServer) requires that the library can be relinked by users, which is satisfied by providing source and build instructions.

### Flash Partition Table

```
# ESP32-S3 16MB Flash Layout
# Name,     Type, SubType, Offset,   Size,     Notes
nvs,        data, nvs,     0x9000,   0x5000,   20KB  — config, WiFi creds, auth tokens
otadata,    data, ota,     0xE000,   0x2000,   8KB   — OTA state tracking
app0,       app,  ota_0,   0x10000,  0x300000, 3MB   — firmware image A
app1,       app,  ota_1,   0x310000, 0x300000, 3MB   — firmware image B (OTA target)
littlefs,   data, spiffs,  0x610000, 0x9F0000, ~10MB — web assets + profiles + shot logs
```

**Space budget within LittleFS (~10MB):**
- Web app assets (HTML/CSS/JS, gzipped): ~200KB
- Shot profiles (20 × ~2KB JSON): ~40KB
- Shot logs (50 × ~20KB with datapoints): ~1MB
- **Remaining:** ~8.7MB free for future use (more shot history, custom sounds, etc.)

### Resource Budget

| Resource | Budget | Breakdown |
|----------|--------|-----------|
| **RAM (512KB SRAM, no PSRAM)** | ~350KB used, ~160KB free | ESP-IDF/WiFi/BLE stack: ~180KB. LVGL frame buffer (320×240×2 bytes × 2 buffers): ~300KB — **PROBLEM: exceeds SRAM.** Must use partial buffer (1/10 screen = ~15KB) or add PSRAM. FreeRTOS tasks: ~47KB. Application heap: ~100KB. |
| **PSRAM (8MB, if WROVER)** | LVGL frame buffer + web response buffers | Moves LVGL buffers to PSRAM, freeing SRAM for application heap. **Recommendation: use WROVER module with PSRAM.** |
| **SPI2 bandwidth** | Display: 26MHz × 16bpp = 52MB/s theoretical, ~15FPS at 320×240 full redraw | Shared with nothing (dedicated bus). Adequate. |
| **SPI3 bandwidth** | MAX31855: < 1MHz, reads < 1KB/s | Shared with nothing (dedicated bus). Negligible load. |
| **I2C0 bandwidth** | CST816 touch: < 10KB/s | Dedicated bus. Negligible. |
| **I2C1 bandwidth** | ADS1115: 128 SPS × 2 bytes = 256 B/s | Dedicated bus. Negligible. |
| **WiFi/BLE coexistence** | ESP-IDF coexistence manager handles time-division | Configure `CONFIG_SW_COEXIST_ENABLE=y`. BLE scan windows may cause ~10ms WiFi latency spikes. Not safety-relevant (control loop is on Core 0, WiFi/BLE on Core 1). |

**Open issue:** LVGL full-screen double buffering requires ~300KB which exceeds available SRAM on WROOM-1. Either use WROVER with PSRAM, or use partial (1/10 screen) buffering with LVGL's `LV_DISPLAY_RENDER_MODE_PARTIAL`. Partial buffering works but increases display latency. **This may resolve the WROOM vs WROVER open question in favor of WROVER.**

### Algorithm Specifications

#### PID Controller

```
Discrete-time positional PID with anti-windup:

    error = setpoint - measured
    P = Kp × error
    I = I_prev + Ki × error × dt
    D = Kd × (error - error_prev) / dt
    output = P + I + D

    // Output clamping
    output = clamp(output, 0.0, max_output)

    // Anti-windup: conditional integration
    // Only accumulate integral if output is not saturated,
    // OR if the integral term would reduce saturation.
    if (output == clamped_output) OR (sign(error) != sign(I)):
        I_prev = I
    else:
        I_prev = I_prev  // freeze integral

    error_prev = error
```

**Form rationale:** Positional (not velocity) form is used because the PID output directly represents the actuator command (0-100% SSR duty or pump power). Velocity form is preferred for integrating actuators (e.g., motor position) but unnecessary here.

**Derivative filter:** A first-order low-pass filter on the derivative term prevents noise amplification:
```
    D_filtered = alpha × D + (1 - alpha) × D_prev    // alpha = 0.1 typical
```

**Cascaded flow control:** When a profile phase is type FLOW, the flow PID's output becomes the *pressure setpoint* for the pressure PID. This is a series cascade:
```
    flow_error = target_flow - measured_flow
    pressure_setpoint = FlowPID.compute(flow_error)
    pressure_error = pressure_setpoint - measured_pressure
    pump_power = PressurePID.compute(pressure_error)
```

#### Transition Curves

The phase profiler interpolates between `target.start` and `target.end` over `duration_ms` using a normalized parameter `t ∈ [0, 1]`:

```
t = elapsed_ms / duration_ms    (clamped to [0, 1])

INSTANT:        output = end                          (step function)
LINEAR:         output = start + (end - start) × t
EASE_IN:        output = start + (end - start) × t²              (quadratic)
EASE_OUT:       output = start + (end - start) × (1 - (1-t)²)   (quadratic)
EASE_IN_OUT:    output = start + (end - start) × (3t² - 2t³)    (smoothstep)
```

#### Phase-Angle Dimmer

```
Input:  pump_power_pct (0-100%)
Output: triac firing delay in microseconds after zero-cross

    // Convert percentage to phase angle (0° = full power, 180° = off)
    // RMS-corrected mapping for linear perceived power:
    phase_angle_rad = acos(2 × pump_power_pct / 100 - 1)
    delay_us = (phase_angle_rad / π) × half_cycle_us

    // half_cycle_us = 10000 for 50Hz mains, 8333 for 60Hz
    // Minimum delay: ~500µs (triac needs time to latch)
    // Maximum delay: half_cycle_us - 500µs (must fire before next zero-cross)
```

**Note:** The RMS-corrected mapping ensures that 50% pump power delivers 50% of the RMS voltage to the motor. A linear angle mapping would result in non-linear power delivery.

#### Predictive Weight

> **TODO(algorithm):** Document the complete predictive weight algorithm. Current description (lines 254-260 in current-state section) covers the heuristic thresholds but not the full computation. Must specify:
> - How puck resistance is computed per sample (pressure_bar / flow_ml_per_s)
> - What smoothing filter is applied (moving average? EMA? window size?)
> - Complete decision tree: initial state → monitoring → output detected → weight estimation active
> - How estimated weight is computed from flow integral minus puck absorption
> - Calibration parameters and their default values
> - Boundary conditions: what happens if flow sensor fails? If pressure sensor fails?

### Interaction Diagrams

#### Shot Lifecycle Sequence

> **TODO(diagram):** Add a sequence diagram showing the complete shot lifecycle:
> 1. User presses brew switch → GPIO interrupt → ControlTask reads switch state
> 2. ControlTask transitions state machine READY → BREWING
> 3. Profile engine starts Phase 0 → sets pump target
> 4. ControlTask reads sensors, runs PID, writes actuators (every 5ms)
> 5. SensorReading published to queue → UITask updates TFT + WebSocket
> 6. ShotDataPoint published to queue → UITask streams to WebSocket clients
> 7. Phase stop condition met → profile engine advances to Phase 1
> 8. Global stop condition met (weight target) → state machine BREWING → DONE
> 9. Pump OFF, solenoid OPEN (3-way valve releases pressure)
> 10. ShotRecord written to LittleFS by PersistenceTask
> 11. 3-second timeout → state machine DONE → IDLE

#### Zero-Cross Dimmer Timing

> **TODO(diagram):** Add a timing diagram showing:
> 1. AC mains sine wave (50Hz = 20ms period, 10ms half-cycle)
> 2. Zero-cross detector output (pulse at each zero crossing)
> 3. Zero-cross ISR fires → starts hardware timer with delay_us
> 4. Timer expires → triac gate pulse (10µs)
> 5. Triac conducts for remainder of half-cycle
> 6. Next zero-cross → triac turns off naturally → repeat

#### BLE Scale Connection

> **TODO(diagram):** Add a sequence diagram showing:
> 1. BLETask starts scan on boot
> 2. Discovers advertised device → calls matchesAdvertisement() on each registered driver
> 3. Matching driver found → connect → discover services/characteristics
> 4. Subscribe to weight notification characteristic
> 5. Driver sends heartbeat per schedule (varies by scale brand)
> 6. Weight notifications arrive → publish ScaleReading to queue
> 7. Disconnect detection → auto-reconnect after 5s backoff

---

## 10. Future State: Safety Architecture

### Safety Design Philosophy: Defense in Depth

The safety architecture uses **three independent layers**. Any single layer failing cannot cause a hazard:

```
Layer 1: SOFTWARE         Layer 2: HARDWARE WATCHDOG     Layer 3: PASSIVE HARDWARE
(PID, fault detection)    (MCU resets if software hangs)  (thermal fuse, OPV)
                                                          Works with NO software,
Can be buggy.             Can fail if MCU is bricked.     NO power to MCU, NO
Catches most faults.      Resets to safe GPIO state.      electronics at all.
```

### Layer 3: Hardware Thermal Fuse (MANDATORY)

**This is the single most important safety component in the system.**

When the stock Gaggia Classic bimetal thermostats are removed (required for PID control), the only hardware over-temperature protection is gone. A thermal fuse must replace it.

```
Mains ──── Thermal Fuse (190°C) ──── SSR ──── Boiler Element
            │
            │  Wired in SERIES with the boiler heating element.
            │  Opens permanently if boiler surface exceeds 190°C.
            │  Works even if: MCU is dead, software has a bug,
            │  SSR is stuck on, thermocouple is disconnected,
            │  power supply has failed, all electronics are destroyed.
            │
            └── Install in the upper thermostat slot on the boiler
                (the slot vacated by the steam thermostat).
```

| Spec | Value |
|------|-------|
| Type | Non-resettable thermal fuse (Microtemp/Cantherm/Aupo) OR resettable bimetal thermostat |
| Temperature rating | 184-192°C (above max steam temp of 165°C, below aluminum damage threshold) |
| Current rating | ≥ 16A at 250VAC (must handle full boiler element current) |
| Mounting | M4 thread into boiler thermostat slot, with thermal paste |
| Cost | $1-3 |

**Alternative:** A resettable bimetal thermostat (KSD301, 180°C NC) can be used instead. It resets automatically when temperature drops. The non-resettable thermal fuse is safer (forces investigation after a fault) but requires replacement.

### Layer 2: Watchdog Timer

```
Hardware Watchdog (ESP32 TWDT)
├── ControlTask must feed watchdog every 100ms
├── Timeout: 500ms (tolerates up to 5 missed feeds before reset,
│   providing margin for transient delays without reducing safety)
├── If not fed → hardware reset → all outputs go to safe state
└── GPIO outputs default to OFF on reset (SSR off, pump off, solenoid off)
```

### Layer 1: Software Fault Detection & Response

| Fault | Detection | Response |
|-------|-----------|----------|
| Thermocouple open/short | MAX31855 fault bits | Immediately disable boiler SSR. Enter FAULT state. |
| Thermocouple reads > 170°C | Temperature threshold | Immediately disable boiler SSR. Enter FAULT state. |
| Pressure sensor reads > 15 bar | Pressure threshold | Immediately stop pump. Open solenoid. Enter FAULT state. |
| Pressure sensor reads < -0.5 bar | Sensor disconnected | Warning only (can still operate). |
| No sensor readings for > 200ms | Timeout | Disable all outputs. Enter FAULT state. |
| Boiler on for > 20 min continuous | Time limit | Disable boiler SSR. Require manual reset. |
| Main loop frequency drops below 50Hz | Performance monitor | Log warning. If < 10Hz, enter FAULT state. |
| SSR commanded off but temp still rising | Stuck SSR detection | Enter FAULT state. Alert user (SSR may need replacement). |
| WiFi/WebSocket connection lost | Network monitor | No action (not safety-relevant). Log warning. |

### GPIO Default State on Reset (CRITICAL)

On ESP32-S3 power-on or watchdog reset, all GPIO pins default to **input mode (high-impedance)**. This means:

- **SSR control pin (GPIO39):** High-impedance → SSR input sees no drive → **SSR OFF** (safe)
- **Dimmer gate pin (GPIO41):** High-impedance → triac gate not triggered → **Pump OFF** (safe)
- **Solenoid control pin (GPIO42):** High-impedance → relay not energized → **Valve closed** (safe)

**Verification required:** The SSR and dimmer modules must be confirmed to have **pull-down resistors** or internal logic that defaults to OFF when the control input is floating. If not, external 10kΩ pull-down resistors must be added to GPIO39, GPIO41, and GPIO42 to guarantee safe state on reset.

```cpp
// First lines of setup(), before ANY other initialization:
void safetyGpioInit() {
    // Force all actuator outputs LOW immediately
    gpio_set_direction(GPIO_NUM_39, GPIO_MODE_OUTPUT);  // SSR
    gpio_set_level(GPIO_NUM_39, 0);
    gpio_set_direction(GPIO_NUM_41, GPIO_MODE_OUTPUT);  // Dimmer gate
    gpio_set_level(GPIO_NUM_41, 0);
    gpio_set_direction(GPIO_NUM_42, GPIO_MODE_OUTPUT);  // Solenoid
    gpio_set_level(GPIO_NUM_42, 0);
}
```

### Protective Earthing

The Gaggia Classic chassis is a **Class I appliance** — it relies on protective earth (ground) for safety. All of the following must be maintained:

1. **Chassis ground:** The mains earth wire must have a secure metal-to-metal connection to the chassis via a ring terminal and bolt. Verify with a multimeter (< 0.1Ω between earth pin and chassis).
2. **SSR heatsink:** If the SSR is mounted on a metal heatsink, the heatsink must either be earthed or insulated from the chassis.
3. **External enclosure:** If the enclosure is metal, it must be bonded to chassis earth. If plastic (ABS/PETG), no earthing needed.
4. **No interruption:** The Open Espresso modification must not interrupt or degrade the existing earth path. Never disconnect or reroute the factory earth wire.

### Safety State Machine

All eight states from the `MachineState` enum (ICD-02), with labeled transitions:

```
                         ┌─────────────────────────────────────────────┐
                         │           FAULT                             │
                         │  All outputs OFF. Notification shown.       │◄─── Any state on:
                         │  Exit: power cycle OR explicit reset cmd    │     - Thermocouple fault
                         └─────────────────────────────────────────────┘     - Over-temp (>170°C)
                              ▲                                              - Over-pressure (>13bar)
                              │ fault                                        - Sensor timeout (>200ms)
                              │ detected                                     - Stuck SSR detected
   ┌───────────┐         ┌────┴──────┐                                       - Continuous heat >20min
   │  HEATING  │────────►│  READY    │                                       - Control loop <10Hz
   │           │  temp ≥ │           │
   │ SSR=PID   │  set-1°C│ SSR=PID   │
   └───────────┘         └─────┬─────┘
        ▲                      │
        │ temp < set-2°C       │ (transitions from READY)
        │ (hysteresis)         ├───────────────────────────────────────┐
   ┌────┴──────┐               │                          │           │
   │   IDLE    │◄──────────────┤                          ▼           ▼
   │           │  brew switch  │ brew switch ON       ┌────────┐  ┌────────────┐
   │ SSR=PID   │  OFF + done   │ + temp ≥ set-2°C    │ STEAM  │  │ DESCALING  │
   │ (heating) │               │                      │        │  │            │
   └───────────┘          ┌────▼──────┐               │ SSR=PID│  │ Pump cycle │
        ▲                 │ BREWING   │               │ (steam │  │ per descale│
        │                 │           │               │  set)  │  │ program    │
        │ shot done /     │ Profile   │               └────┬───┘  └─────┬──────┘
        │ switch OFF      │ engine    │                    │            │
        │                 │ active    │  steam switch OFF  │ done       │
        │                 └─────┬─────┘                    │            │
        │                       │                          │            │
        │ timeout (3s)    ┌─────▼─────┐                    │            │
        ├─────────────────┤   DONE    │◄───────────────────┘            │
        │                 │           │◄────────────────────────────────┘
        │                 │ Show shot │
        │                 │ summary   │
   ┌────┴──────┐         └───────────┘
   │ FLUSHING  │
   │           │◄── flush button / backflush command
   │ Pump ON,  │
   │ solenoid  │
   │ cycle     │
   └───────────┘
```

**Transition guards:**

| From | To | Trigger | Guard Conditions |
|------|-----|---------|-----------------|
| IDLE | HEATING | Boot / temp drops | `temp < setpoint - 2°C` |
| HEATING | READY | Temp reached | `temp ≥ setpoint - 1°C` (hysteresis) |
| READY | BREWING | Brew switch ON | `temp ≥ setpoint - 2°C AND no active fault` |
| READY | STEAM | Steam switch ON | `steam_switch == HIGH` |
| READY | DESCALING | Descale command | `via web UI or TFT menu` |
| READY | FLUSHING | Flush command | `via web UI, TFT, or backflush switch combo` |
| BREWING | DONE | Shot complete | `any global stop condition met OR brew switch OFF` |
| STEAM | DONE | Steam complete | `steam_switch == LOW` |
| FLUSHING | IDLE | Flush complete | `flush cycle finished` |
| DESCALING | DONE | Descale complete | `descale program finished` |
| DONE | IDLE | Timeout | `3 seconds after shot end` |
| *any* | FAULT | Fault detected | See fault table in Layer 1 above |
| FAULT | IDLE | Manual reset | `power cycle OR explicit reset command via API` |

**Note:** The physical brew switch is the **hardware authority** for shot start/stop. If the brew switch is OFF, a WebSocket `start_shot` command is ignored. If the brew switch is turned OFF during a shot, the shot stops immediately regardless of software state.

### Compile-Time Safety Limits

```cpp
// safety_limits.h — these are NOT configurable at runtime
constexpr float MAX_BOILER_TEMP_C = 170.0f;
constexpr float MAX_BREW_PRESSURE_BAR = 13.0f;
constexpr float MAX_STEAM_TEMP_C = 165.0f;
constexpr uint32_t MAX_CONTINUOUS_HEAT_MS = 20 * 60 * 1000; // 20 minutes
constexpr uint32_t WATCHDOG_TIMEOUT_MS = 500;
constexpr uint32_t SENSOR_TIMEOUT_MS = 200;
constexpr float PUMP_MAX_POWER_PCT = 100.0f;
constexpr float STUCK_SSR_TEMP_RISE_THRESHOLD = 5.0f;  // °C rise after SSR off = stuck
constexpr uint32_t STUCK_SSR_DETECT_MS = 3000;          // check 3s after SSR off command
```

---

## 11. Future State: Profile Engine

The profile engine is one of the strongest parts of the current design. The rewrite should preserve its semantics while cleaning up the implementation.

### Profile Data Model

```
Profile
├── name: string (max 32 chars)
├── phases: Phase[] (1-10 phases)
│   ├── type: PRESSURE | FLOW
│   ├── target: Transition
│   │   ├── start: float (optional, default 0, -1 = "from current")
│   │   ├── end: float
│   │   ├── curve: INSTANT | LINEAR | EASE_IN | EASE_OUT | EASE_IN_OUT
│   │   └── duration_ms: uint32
│   ├── restriction: float (-1 = none)
│   │   (max flow if type=PRESSURE, max pressure if type=FLOW)
│   ├── stop_conditions: StopConditions
│   │   ├── time_ms: int32 (-1 = disabled)
│   │   ├── pressure_above: float (-1 = disabled)
│   │   ├── pressure_below: float (-1 = disabled)
│   │   ├── flow_above: float (-1 = disabled)
│   │   ├── flow_below: float (-1 = disabled)
│   │   ├── weight_g: float (-1 = disabled)
│   │   └── water_pumped_ml: float (-1 = disabled)
│   └── temperature_target: float (per-phase temperature)
│
└── global_stop_conditions: GlobalStopConditions
    ├── time_ms: int32 (-1 = disabled)
    ├── weight_g: float (-1 = disabled)
    └── water_pumped_ml: float (-1 = disabled)
```

### Example Profile: Classic 9-Bar Shot

```json
{
  "name": "Classic 9 Bar",
  "phases": [
    {
      // Phase 0: Pre-infusion. Ramp to 3 bar over 5s.
      // Ends when pressure reaches 3 bar (~5s normally) or after 8s (timeout).
      "type": "PRESSURE",
      "target": {"end": 3.0, "curve": "LINEAR", "duration_ms": 5000},
      "restriction": -1,
      "stop_conditions": {"time_ms": 8000, "pressure_above": 3.0},
      "temperature_target": 93.0
    },
    {
      // Phase 1: Main extraction. Ramp to 9 bar over 3s, then hold.
      // No phase-level stop — global stop conditions apply (36g or 60s).
      "type": "PRESSURE",
      "target": {"end": 9.0, "curve": "EASE_IN", "duration_ms": 3000},
      "restriction": -1,
      "stop_conditions": {},
      "temperature_target": 93.0
    }
  ],
  "global_stop_conditions": {
    "weight_g": 36.0,
    "time_ms": 60000
  }
}
```

**Note:** The `target.start` field is optional (defaults to 0). Use `-1` for "from current value" to allow smooth transitions between phases without jumps.

### Profile Storage

- Profiles stored as JSON in LittleFS (not binary blobs)
- Validated on load against schema
- Up to 20 profiles (LittleFS has more space than EEPROM)
- Profiles can be exported/imported via web UI
- Default profiles shipped with firmware

---

## 12. Future State: Data Model

### Configuration (replaces eepromValues_t)

```
SystemConfig                          (stored in NVS)
├── wifi_ssid: string
├── wifi_password: string
├── ble_scales_address: string
├── display_brightness: uint8 (0-100)
├── display_timeout_s: uint16
├── active_profile_index: uint8
│
├── boiler: BoilerConfig
│   ├── brew_temp_c: float (default: 93.0)
│   ├── steam_temp_c: float (default: 155.0)
│   ├── offset_temp_c: float (default: 0.0)
│   ├── pid_kp: float
│   ├── pid_ki: float
│   └── pid_kd: float
│
├── pump: PumpConfig
│   ├── pressure_pid_kp: float
│   ├── pressure_pid_ki: float
│   ├── pressure_pid_kd: float
│   ├── flow_pid_kp: float
│   ├── flow_pid_ki: float
│   └── flow_pid_kd: float
│
├── scales: ScalesConfig
│   ├── calibration_factor_1: float
│   ├── calibration_factor_2: float
│   └── predictive_enabled: bool
│
└── version: uint32 (schema version for migration)
```

### Shot Log

```
ShotRecord                            (stored in LittleFS as JSON)
├── timestamp: uint32 (epoch seconds)
├── profile_name: string
├── duration_ms: uint32
├── total_weight_g: float
├── total_volume_ml: float
├── avg_temperature_c: float
├── avg_pressure_bar: float
├── peak_pressure_bar: float
├── datapoints: ShotDataPoint[]       (sampled every 100ms)
│   ├── time_ms: uint32
│   ├── temperature_c: float
│   ├── pressure_bar: float
│   ├── flow_ml_s: float
│   ├── weight_g: float
│   ├── target_pressure: float
│   └── target_flow: float
└── notes: string (user annotation)
```

---

## 13. Gaggia Classic (Pre-2015) Machine-Specific Notes

### Machine Specifications

The pre-2015 Gaggia Classic (sold until ~2014-2016 depending on region, before the "New Classic" / "Classic Pro" redesign):

| Specification | Value |
|--------------|-------|
| Boiler | Aluminum, ~100ml capacity |
| Heating element | 1000W (EU, ~4.3A at 230V) / 1425W (US, ~11.9A at 120V). Different elements per region. |
| Pump | Ulka EP5 vibratory pump (52W) |
| Solenoid | 3-way solenoid valve (OPV + brew path) |
| OPV | Adjustable over-pressure valve (factory set ~12 bar) |
| Group head | E61-style 58mm (not true E61 thermosiphon) |
| Voltage | 120V (US) / 220-240V (EU/UK/AU) |
| Brew thermostat | Stock: 107°C bimetal thermostat (removed for Gaggiuino) |
| Steam thermostat | Stock: 145°C bimetal thermostat (removed for Gaggiuino) |
| Water reservoir | ~2.1L removable tank |

### Wiring Considerations

For the Gaggiuino mod, the following stock components are replaced or augmented:

1. **Thermostats removed** — Both brew and steam thermostats are replaced by the thermocouple + SSR combination. The SSR is wired in place of the brew thermostat.

2. **Pump control** — The dimmer module is wired in series with the pump. The stock pump switch still functions as a master enable.

3. **Pressure tap** — A T-fitting is added to the boiler output (between the boiler and the group head) for the pressure transducer.

4. **Flow sensor** — Inline with the pump output, before the boiler.

5. **Three-way solenoid** — Stock solenoid is retained. Gaggiuino can optionally control it for automated backflushing, but the stock manual operation also works.

### Voltage / Region Considerations

For the 2016 Gaggia Classic specifically:
- **EU model (220-240V):** Dimmer and SSR must be rated for mains voltage. The triac in the dimmer sees full mains.
- **US model (120V):** Same dimmer circuit works but current draw is higher for the same power. Triac and SSR current ratings matter more.
- **The OPV should be adjusted to ~9 bar** (stock is ~12 bar). This is a mechanical adjustment, not firmware-controlled, but it is essential for proper pressure profiling. Without it, the pump will always push 12+ bar and the dimmer has to fight the OPV.

---

## 14. Hardware Inventory: Current vs New BOM

### What Changes

| Component | Current Gaggiuino | New Design | Change? |
|-----------|------------------|------------|---------|
| **MCU (control)** | STM32F411CE "Blackpill" | ESP32-S3-WROOM-1 (or WROVER) | **Replace** — single MCU does both |
| **MCU (UI/network)** | ESP32-S2 or S3 | (same chip as above) | **Eliminated** |
| **Display** | Nextion 2.4-4.3" UART | ILI9341 2.8" SPI TFT | **Replace** |
| **Thermocouple** | K-type + MAX31855 (SPI) | K-type + MAX31855 (SPI) | **Keep** (evaluate MAX31856) |
| **Pressure sensor** | 0-1.2MPa transducer + ADS1115 (I2C) | Same transducer + ADS1115 (I2C) | **Keep** (evaluate ADS1220) |
| **Flow sensor** | Hall-effect, GPIO interrupt | Same sensor, same interface | **Keep** |
| **Boiler SSR** | Solid-state relay, GPIO | Same SSR, GPIO | **Keep** |
| **Pump dimmer** | Zero-cross + triac module | Same dimmer circuit | **Keep** |
| **Solenoid control** | GPIO (optional) | GPIO (optional) | **Keep** |
| **BLE scales** | Acaia/Felicita/Decent/Bookoo via ESP32 BLE | Same, via ESP32-S3 BLE | **Keep** |
| **UART bridge** | Custom protocol, 115200 baud | **Eliminated** | **Eliminated** |
| **Power supply** | 5V/3.3V regulator for MCUs | Same (one MCU instead of two) | **Simplify** |
| **PCB** | GaggiaBoard V3/V4 (STM32 + ESP32 on one board) | New single-MCU board | **Redesign** |
| **Wiring harness** | Low-voltage + high-voltage mixed inside machine | Separated: sensors inside, electronics outside | **Redesign** |

### What's Eliminated

Removing the dual-MCU architecture eliminates:
- STM32F411CE module (~$5)
- UART level shifter (if any)
- Inter-MCU wiring (4+ wires)
- Nextion display + cable (~$15-40)
- Complexity of two firmware images

### New BOM (Estimated)

| Component | Qty | Est. Cost | Notes |
|-----------|-----|-----------|-------|
| ESP32-S3-WROOM-1 (N16R8) | 1 | $3-4 | 16MB flash, 8MB PSRAM. WROVER if ext. antenna needed |
| ILI9341 2.8" TFT + touch | 1 | $5 | SPI, CST816 capacitive or XPT2046 resistive |
| ADS1115 ADC module | 1 | $2 | 16-bit, I2C. For pressure transducer |
| MAX31855 breakout | 1 | $3 | SPI. For K-type thermocouple |
| K-type thermocouple (M4) | 1 | $3 | Screws into boiler thermostat hole |
| Pressure transducer (0-1.2MPa) | 1 | $8-12 | XDB401 or equivalent, 0.5-4.5V output |
| Flow sensor (hall-effect) | 1 | $5-8 | Inline, pulse output |
| SSR (40A) | 1 | $4-6 | For boiler heating element |
| **Thermal fuse (184-192°C, 16A)** | 1 | $1-3 | **SAFETY-CRITICAL.** In series with boiler element. M4 mount in upper thermostat slot. [R06] |
| AC dimmer module | 1 | $4-6 | Zero-cross + triac (RobotDyn or equivalent) |
| EMI filter (AC line) | 1 | $2-3 | LC filter on dimmer AC input. Reduces conducted emissions from phase-angle switching. |
| 5V power supply (derating) | 1 | $2-3 | Hi-Link HLK-PM01 or equivalent, AC→5V |
| 3.3V LDO regulator | 1 | $0.50 | AMS1117-3.3 or similar, from 5V rail |
| Pull-down resistors (10kΩ) | 3 | $0.10 | On SSR, dimmer gate, solenoid GPIOs. Ensures safe state on MCU reset. |
| Snubber (RC, 100Ω+100nF) | 1 | $0.50 | Across dimmer triac. Reduces EMI and protects triac from inductive spikes. |
| External enclosure | 1 | $5-15 | IP54+ rated, or 3D-printed PETG with gasket |
| Cable glands (PG7/PG9) | 4-6 | $3 | Waterproof cable pass-throughs for enclosure |
| Connectors (JST-XH or similar) | ~10 | $3 | Disconnect points for all sensor cables |
| PTFE tubing | 1m | $2 | For pressure transducer T-fitting |
| T-fitting (1/8" BSP) | 1 | $3 | Pressure tap between boiler and group |
| Wire (silicone, various gauge) | - | $5 | High-temp silicone insulation for inside machine |
| **Total estimated** | | **~$65-90** | |

### What Stays Inside the Machine (Unavoidable)

These components **must** remain inside the Gaggia chassis because they connect directly to the boiler, pump, or plumbing:

1. **Thermal fuse (190°C)** — in series with boiler element, in upper thermostat slot. **SAFETY-CRITICAL.**
2. **K-type thermocouple** — screwed into the lower boiler thermostat hole
3. **SSR** — switches mains AC to the heating element (mounts near boiler wiring)
4. **Dimmer module + EMI filter + snubber** — wired in series with the pump (near pump wiring)
5. **Pressure transducer** — connected to plumbing via T-fitting
6. **Flow sensor** — inline with pump output tubing
7. **Solenoid relay** (if used) — switches the 3-way valve
8. **Power supply module** — converts mains AC to 5V DC

These are either plumbing-connected, high-voltage, or both. They're also robust components (sealed transducer, potted SSR, etc.) that tolerate humidity better than bare PCBs.

### What Moves Outside the Machine

All sensitive low-voltage electronics:

1. **ESP32-S3 MCU** — the brain
2. **TFT display** — user interface
3. **ADS1115 ADC** — analog-to-digital converter for pressure
4. **MAX31855** — thermocouple interface IC
5. **Any capacitors, pull-ups, or signal conditioning** on the sensor lines

---

## 15. Physical Design: External Electronics Enclosure

### The Problem

Inside the Gaggia Classic:
- Steam and water vapor from the boiler, group head, and drip tray
- Heat radiation from the boiler (~100-165°C surface temperature)
- Potential drips from the water tank area and plumbing fittings
- Cramped space (~230mm × 240mm footprint, most occupied by boiler + pump)
- High-voltage AC wiring running alongside low-voltage signal wires

The current Gaggiuino design places the PCB inside the machine, either loose or in a 3D-printed PETG housing with magnetic mounting. This works, but any leak or condensation event can destroy the electronics.

### The Solution: External Enclosure on the Back

Mount all sensitive electronics in a sealed enclosure attached to the **rear panel** of the Gaggia Classic, with only sensor and power cables passing through the chassis.

```
         ┌──────────────────────────────────────────────┐
         │              GAGGIA CLASSIC                   │
         │            (rear view, 230mm wide)            │
         │                                               │
         │   ┌─────┐                                     │
         │   │vent │          ┌───────┐                  │
         │   │holes│          │ power │  (IEC C14 inlet) │
         │   └─────┘          │ inlet │                  │
         │                    └───────┘                  │
         │                                               │
         │   ══════════════════════════════  (bottom)     │
         └──────────────────────────────────────────────┘
                            │
               Cable glands │ (PG7/PG9)
               pass through │ rear panel
                            │
         ┌──────────────────┴───────────────────────────┐
         │          EXTERNAL ENCLOSURE                   │
         │          (~120mm × 80mm × 40mm)               │
         │                                               │
         │   ┌───────────────────────────────────────┐   │
         │   │  ESP32-S3          MAX31855   ADS1115 │   │
         │   │  ┌────────┐      ┌───┐       ┌───┐   │   │
         │   │  │        │      │   │       │   │   │   │
         │   │  └────────┘      └───┘       └───┘   │   │
         │   │                                       │   │
         │   │  Signal conditioning / connectors      │   │
         │   └───────────────────────────────────────┘   │
         │                                               │
         │   ┌───────────────────────────────────────┐   │
         │   │  ILI9341 2.8" TFT                     │   │
         │   │  (window cutout in enclosure lid)      │   │
         │   └───────────────────────────────────────┘   │
         │                                               │
         └───────────────────────────────────────────────┘
```

### Cable Routing

Seven cables pass through the rear panel via cable glands:

```
Inside Machine                    Cable Gland        External Enclosure
─────────────────                 ───────────        ──────────────────

Thermocouple (boiler) ──── 2-wire analog ─ PG7 ──── MAX31855 (SPI to ESP32 inside enclosure)
Pressure transducer ────── 3-wire analog ── PG7 ──── ADS1115
Flow sensor ────────────── 3-wire digital ─ PG7 ──── ESP32 GPIO
SSR control ────────────── 2-wire logic ─── PG7 ──── ESP32 GPIO
Dimmer control ─────────── 3-wire (ZC+gate+GND) ── PG7 ── ESP32 GPIO
Solenoid relay (optional) ─ 2-wire logic ── PG7 ──── ESP32 GPIO
5V DC power ────────────── 2-wire DC ───── PG7 ──── ESP32 + display

Total: 7 cable glands (PG7 for individual cables, or fewer PG9 for bundled cables)
```

### Mounting Options

**Option 1: Rear-panel mount (recommended)**

Attach the enclosure to the rear panel of the Gaggia Classic using:
- **Magnets** — The Gaggia Classic chassis is steel/stainless. Strong neodymium magnets (N52, 10mm × 3mm) on the enclosure grip the rear panel. No drilling required. Removable for maintenance.
- **VHB tape** — 3M VHB double-sided tape as a backup/supplement to magnets. Withstands vibration from the pump.

The rear panel is the best location because:
- It's the coolest surface (farthest from boiler)
- It's not visible from the front
- It's above the counter (no water pooling)
- Cables route straight through to internal components

**Option 2: Side-panel mount**

Same concept but on the left or right side panel. Less ideal because:
- Side panels are closer to the boiler
- More visible
- May interfere with machine placement against a wall

**Option 3: Underneath mount**

Mount under the machine. Not recommended:
- Vulnerable to counter spills
- Hard to access for maintenance
- Needs clearance (machine feet are short)

### Enclosure Specifications

| Spec | Value |
|------|-------|
| Material | ABS or PETG (3D printed) or IP54 ABS project box |
| Dimensions | ~120mm × 80mm × 45mm (fits ESP32 dev board + TFT + breakouts) |
| IP rating | IP54 minimum (dust protected, splash resistant) |
| Display window | Cutout with clear acrylic or polycarbonate cover, sealed with gasket |
| Cable entry | Bottom or side, PG7 cable glands (IP68 rated) |
| Mounting | Neodymium magnets (4× N52 10mm×3mm) recessed into enclosure |
| Ventilation | None needed — ESP32-S3 dissipates <1W. Sealed is better. |
| Access | Removable lid secured with 4 screws + silicone gasket |

### Display Integration

The 2.8" TFT sits behind a window cutout in the enclosure lid:

```
┌─────────────────────────────────────────┐
│           ENCLOSURE LID (top view)       │
│                                          │
│   ┌───────────────────────────────┐      │
│   │                               │      │
│   │     2.8" TFT visible area     │      │
│   │       (approx 57mm × 43mm)    │      │
│   │                               │      │
│   └───────────────────────────────┘      │
│    clear acrylic window + foam gasket    │
│                                          │
│   ○ USB-C access port (for flashing)     │
│                                          │
└─────────────────────────────────────────┘
```

- The acrylic window is sealed with a thin foam gasket to keep moisture out
- Touch works through thin acrylic/polycarbonate (capacitive touch, not resistive)
- A small USB-C port with a rubber plug allows firmware flashing without opening the enclosure

### Internal Layout

```
┌──────────────────────────────────────────────────────┐
│  ENCLOSURE INTERIOR (lid removed, top view)           │
│                                                       │
│  ┌────────────────────────┐  ┌─────────┐  ┌───────┐ │
│  │                        │  │ MAX31855│  │ADS1115│ │
│  │     ESP32-S3 Dev       │  │ breakout│  │  ADC  │ │
│  │     Board              │  │         │  │       │ │
│  │     (e.g. DevKitC-1)   │  └─────────┘  └───────┘ │
│  │                        │                          │
│  └────────────────────────┘                          │
│                                                       │
│  ┌──────────────────────────────────────────────────┐│
│  │         ILI9341 2.8" TFT (face-down toward lid) ││
│  │         (FPC cable to ESP32 SPI)                 ││
│  └──────────────────────────────────────────────────┘│
│                                                       │
│  ═══ ═══ ═══ ═══ ═══ ═══ ═══  (cable gland entries) │
│  TC  PSI  FLW  SSR  DIM  SOL  5V                     │
└──────────────────────────────────────────────────────┘
```

### Inside the Machine: What Remains

With the electronics outside, the interior of the Gaggia Classic only has:

```
┌─────────────────────────────────────────────┐
│          GAGGIA CLASSIC INTERIOR             │
│          (top view, lid removed)             │
│                                              │
│  ┌────────┐                    ┌──────────┐ │
│  │ Water  │                    │  Boiler   │ │
│  │ Tank   │                    │           │ │
│  │        │     ┌──────┐       │  TC here  │ │
│  │        │     │ Pump │       │  (M4)     │ │
│  └────────┘     │      │       └──────────┘ │
│                  │ Flow │                     │
│                  │sensor│    ┌──────────────┐│
│                  │ here │    │  SSR         ││
│                  └──────┘    │  (potted,    ││
│                              │   moisture   ││
│    ┌──────────┐              │   tolerant)  ││
│    │ Dimmer   │              └──────────────┘│
│    │ module   │                              │
│    │ (near    │    ┌─────────┐               │
│    │  pump    │    │Pressure │               │
│    │  wiring) │    │transducr│               │
│    └──────────┘    │(sealed) │               │
│                    └─────────┘               │
│                                              │
│  ════ cables exit via rear panel glands ════ │
└─────────────────────────────────────────────┘
```

**Key points:**
- The SSR is potted/sealed — moisture tolerant. Mount it near the boiler wiring with thermal pad if needed.
- The dimmer module is near the pump wiring. These modules are typically conformal-coated or potted.
- The pressure transducer is a sealed industrial sensor — waterproof by design.
- The flow sensor is an inline plumbing component — waterproof by design.
- The thermocouple is a sealed probe — waterproof by design.
- The 5V PSU (Hi-Link or similar) is a potted module — moisture tolerant.
- **No bare PCBs or exposed ICs remain inside the machine.**

### High-Voltage / Low-Voltage Separation

Inside the machine, high-voltage AC wiring (mains, boiler, pump) and low-voltage signal wiring (sensor outputs, SSR/dimmer control) must be physically separated:

```
LEFT SIDE (high voltage)           RIGHT SIDE (low voltage signals)
─────────────────────────          ──────────────────────────────
Mains input                        Thermocouple 2-wire
Boiler element leads               Pressure transducer 3-wire
Pump motor leads                   Flow sensor 3-wire
SSR output (switched mains)        SSR control (3.3V logic)
Dimmer output (switched mains)     Dimmer ZC + gate (3.3V logic)
                                   5V DC power cable
```

Low-voltage signal cables should use **shielded or twisted-pair wire** where possible, and be bundled through separate cable glands from any AC wiring.

---

## 16. Requirements Specification

Numbered requirements for traceability. Each requirement has a unique ID, is testable, and maps to a verification method in section 18 and to the design module(s) that implement it (see traceability matrix at end of section 18).

**Requirement attributes:** ID (unique), requirement text (testable "shall" statement), priority (P0=safety-critical, P1=required, P2=important, P3=nice-to-have), rationale (why this threshold/value), source (where the requirement originates), and verification method.

### Safety Requirements

| ID | Requirement | Pri | Rationale | Source | Verification |
|----|-------------|-----|-----------|--------|-------------|
| REQ-S-001 | The system shall include a hardware thermal fuse (184-192°C) wired in series with the boiler heating element, independent of all software and electronics. | P0 | Stock thermostats are removed for PID control; thermal fuse replaces this safety layer. 190°C is above max steam temp (165°C) but below aluminum boiler damage threshold. | IEC 60335-2-15 | T-S-001 |
| REQ-S-002 | On MCU power-on or watchdog reset, all actuator outputs (SSR, dimmer, solenoid) shall default to OFF within 1ms. | P0 | Prevents actuators from being in an unknown state during boot or after a crash. | IEC 61508 | T-S-002 |
| REQ-S-003 | The boiler SSR shall be disabled within 100ms of detecting a thermocouple fault (open, short, or out-of-range). | P0 | Without temperature feedback, boiler cannot be safely controlled. 100ms is 2× the sensor read period. | IEC 61508 | T-S-003 |
| REQ-S-004 | The boiler SSR shall be disabled if boiler temperature exceeds 170°C (software limit). | P0 | 170°C provides margin: above steam max (165°C) and below thermal fuse trip (184°C). | IEC 60335-2-15 | T-S-004 |
| REQ-S-005 | The pump shall be stopped and solenoid opened if pressure exceeds 13 bar (software limit). | P0 | Stock OPV is set to 9 bar; 13 bar provides margin for sensor error while protecting fittings. ADS1115 sensor range is 0-12 bar. | Safety analysis | T-S-005 |
| REQ-S-006 | The hardware watchdog shall reset the MCU if the control loop fails to feed it within 500ms. | P0 | 500ms timeout allows 5 missed 100ms feeds, providing tolerance for transient delays without reducing safety margin. | IEC 61508 | T-S-006 |
| REQ-S-007 | The boiler SSR shall be disabled after 20 minutes of continuous heating. | P1 | Protects against forgotten-on scenarios. Normal brew cycle is < 2 minutes; steam is < 5 minutes. | Safety analysis | T-S-007 |
| REQ-S-008 | The system shall detect a stuck-on SSR (temperature rising > 5°C after SSR off command within 3s) and enter FAULT state. | P1 | SSR failure mode (shorted thyristor) causes continuous heating. 3s detection window balances speed vs thermal inertia false positives. | FMEA (section 17) | T-S-008 |
| REQ-S-009 | All actuator GPIO pins shall have external 10kΩ pull-down resistors to ensure safe state when MCU is in reset or unpowered. | P0 | ESP32-S3 GPIOs are high-impedance on reset; pull-downs guarantee actuators OFF even with no firmware running. | IEC 61508 | T-S-002 |
| REQ-S-010 | The chassis earth connection shall not be interrupted or degraded by the modification. Earth continuity shall be < 0.1Ω. | P0 | Gaggia Classic is Class I (protective earth). Any modification that breaks the earth path creates electrocution risk. | IEC 60335-1 | T-S-009 |
| REQ-S-011 | High-voltage (mains) and low-voltage (signal) wiring shall be physically separated inside the machine. | P1 | Prevents induced noise on signal wires and reduces risk of insulation failure causing signal lines to contact mains. | EMC / safety best practice | T-S-010 |
| REQ-S-012 | An EMI filter shall be installed on the AC dimmer input to reduce conducted emissions. | P1 | Phase-angle dimming generates significant conducted EMI that can affect other electronics on the same circuit. | EMC best practice | Inspection |

### Functional Requirements

| ID | Requirement | Pri | Source | Verification |
|----|-------------|-----|--------|-------------|
| REQ-F-001 | The system shall control boiler temperature to within ±1°C of the setpoint at steady state. | P1 | User need (consistent brew temp) | T-F-001 |
| REQ-F-002 | The system shall control brew pressure to within ±0.5 bar of the profile target during extraction. | P1 | User need (profile accuracy) | T-F-002 |
| REQ-F-003 | The system shall execute multi-phase shot profiles with up to 10 phases, each with configurable type (pressure/flow), target transition, and stop conditions. | P1 | Legacy feature parity | T-F-003 |
| REQ-F-004 | The system shall advance to the next profile phase when any configured stop condition is met. | P1 | Profile engine design | T-F-003 |
| REQ-F-005 | The system shall terminate the shot when any global stop condition is met (time, weight, volume). | P1 | Profile engine design | T-F-003 |
| REQ-F-006 | The system shall read thermocouple temperature at ≥ 10 Hz. | P1 | MAX31855 hardware limit (REQ-P-002) | T-F-011 |
| REQ-F-007 | The system shall read pressure at ≥ 10 Hz. | P1 | PID control minimum | T-F-011 |
| REQ-F-008 | The system shall read flow rate continuously via interrupt-driven pulse counting. | P1 | Flow profiling accuracy | T-F-011 |
| REQ-F-009 | The system shall support BLE scale connection with weight reading at ≥ 5 Hz. | P2 | Weight-based stop conditions | T-F-012 |
| REQ-F-010 | The system shall store up to 20 shot profiles in LittleFS. | P2 | User need (multiple profiles) | T-F-013 |
| REQ-F-011 | The system shall log shot data (datapoints at 100ms intervals) and store at least 50 shot records. When storage is full, the oldest record shall be deleted automatically. | P2 | User need (shot review) | T-F-013 |
| REQ-F-012 | The system shall provide OTA firmware update via the web interface, protected by a password. | P1 | User need (easy updates) | T-F-004, T-F-005 |
| REQ-F-013 | The system shall serve a web application accessible from any browser on the local network. | P1 | User need (phone control) | T-F-006 |
| REQ-F-014 | The system shall stream real-time sensor data via WebSocket at ≥ 10 Hz during shots. | P1 | User need (remote monitoring) | T-F-007 |
| REQ-F-015 | The system shall provide a REST API (versioned, /api/v1) for profile CRUD, config, and shot history. | P1 | Community / integration need | T-F-006 |
| REQ-F-016 | The system shall display temperature, pressure, flow, shot timer, and weight on the TFT display during shots. | P1 | User need (local monitoring) | Visual inspection |
| REQ-F-017 | The system shall display current temperature and ready/heating status on the TFT display when idle. | P1 | User need (ready indication) | Visual inspection |
| REQ-F-018 | The system shall support steam mode: heat boiler to steam setpoint (configurable, default 155°C), indicate steam ready on TFT, and disable steam after steam switch is turned off. | P1 | Legacy feature parity | T-F-014 |
| REQ-F-019 | The system shall support flush mode: run the pump at a fixed power level for a configurable duration, cycling the solenoid for backflush. | P2 | User need (machine cleaning) | T-F-014 |
| REQ-F-020 | The system shall support descale mode: run a pre-defined pump cycle (on/off intervals) for descaling solution. | P3 | User need (maintenance) | T-F-014 |
| REQ-F-021 | The physical brew switch shall be the hardware authority for shot start/stop. If the brew switch is OFF, a WebSocket start_shot command shall be ignored. If the brew switch is turned OFF during a shot, the shot shall stop immediately. | P1 | Safety (hardware interlock) | T-F-015 |
| REQ-F-022 | Configuration changes shall persist across power cycles via NVS. Invalid configurations shall be rejected and the previous valid configuration shall be retained. | P1 | Reliability | T-F-016 |
| REQ-F-023 | The system shall support WiFi connection with auto-reconnect. If WiFi is unavailable, the system shall continue operating (PID, display, profiles) without WiFi. | P1 | Reliability | T-F-017 |
| REQ-F-024 | The system shall be discoverable on the local network via mDNS (hostname: `espresso.local`). | P2 | Usability (no IP lookup) | T-F-006 |
| REQ-F-025 | The system shall support profile import and export via the web UI (JSON format). | P2 | Community (profile sharing) | T-F-018 |
| REQ-F-026 | The system shall estimate espresso output weight from flow data (predictive weight) when BLE scales are not connected. | P2 | Legacy feature parity | T-F-019 |
| REQ-F-027 | The system shall support config migration: when firmware is updated and the config schema version changes, existing config shall be automatically migrated to the new schema. | P1 | Reliability (OTA robustness) | T-U-005 |

### Security Requirements

| ID | Requirement | Pri | Rationale | Source | Verification |
|----|-------------|-----|-----------|--------|-------------|
| REQ-SEC-001 | Write operations (REST PUT/POST/DELETE, WebSocket commands) shall require a session token obtained by authenticating with a PIN. | P1 | Prevents unauthorized changes from any device on the WiFi. | IEC 62443-4-2 | T-F-005, T-F-020 |
| REQ-SEC-002 | Destructive operations (OTA, restart, factory-reset) shall require a separate admin password. | P1 | Higher bar for actions that can brick or wipe the device. | IEC 62443-4-2 | T-F-004, T-F-005 |
| REQ-SEC-003 | Default PIN (1234) and default OTA password (openespresso) shall be set at factory. The web app shall prompt the user to change both on first connection if defaults are still active. | P1 | Prevents shipping with no auth. | IEC 62443-4-2 | T-F-020 |
| REQ-SEC-004 | The auth endpoint (POST /api/v1/auth) shall be rate-limited to 5 attempts per minute. The OTA endpoint shall be rate-limited to 3 attempts per minute. | P1 | Prevents brute-force attacks on the local network. | IEC 62443-4-2 | T-F-020 |
| REQ-SEC-005 | GET /config shall never return wifi_password in the response body. The field shall be write-only. | P1 | Prevents WiFi credential disclosure to any device on the network. | IEC 62443-4-2 | T-F-020 |
| REQ-SEC-006 | Session tokens shall be 32-byte cryptographically random values, valid until device reboot. | P2 | Adequate for single-user home network. No persistent sessions needed. | IEC 62443-4-2 | Code review |

### Data Requirements

| ID | Requirement | Pri | Rationale | Source | Verification |
|----|-------------|-----|-----------|--------|-------------|
| REQ-D-001 | Shot log storage shall use a FIFO eviction policy: when the 50-record limit is reached, the oldest record shall be deleted before writing a new one. | P2 | Prevents storage-full errors that would lose current shot data. | Design decision | T-F-013 |
| REQ-D-002 | Profile JSON values shall be validated on import: pressure targets 0-15 bar, temperature targets 0-170°C, flow targets 0-10 ml/s, duration 0-120000ms, max 10 phases. | P1 | Prevents invalid profiles from causing unexpected actuator behavior. | Safety analysis | T-F-018 |
| REQ-D-003 | The system shall support export of all user data (config, profiles, shot history) via the REST API for backup purposes. | P2 | Prevents data loss on flash corruption or device replacement. | User need | T-F-018 |
| REQ-D-004 | If NVS is corrupted or unreadable, the system shall fall back to compiled-in default configuration and notify the user. | P1 | Prevents boot failure from flash corruption. | Reliability | T-F-016 |

### Performance Requirements

| ID | Requirement | Value | Pri | Rationale | Verification |
|----|-------------|-------|-----|-----------|-------------|
| REQ-P-001 | Control loop frequency (PID + sensor read + actuator write) | ≥ 200 Hz (5ms period) | P1 | ControlTask runs at 5ms period. Provides 4-5 iterations per half-cycle at 50Hz mains for precise dimmer timing. | T-F-008 |
| REQ-P-002 | Sensor polling rate (temperature) | ≥ 10 Hz | P1 | MAX31855 conversion time is ~100ms; 10 Hz is the practical maximum. | T-F-011 |
| REQ-P-003 | Sensor polling rate (pressure) | ≥ 50 Hz | P1 | ADS1115 at 128 SPS in continuous mode; 50 Hz achievable. | T-F-011 |
| REQ-P-004 | TFT display refresh rate | ≥ 15 FPS | P2 | Smooth enough for real-time graphs on 320×240 via SPI. | T-F-021 |
| REQ-P-005 | WebSocket data rate | ≥ 10 messages/sec during shot | P1 | 100ms interval; adequate for remote graph rendering. | T-F-007 |
| REQ-P-006 | Web app initial load time | < 3 seconds | P2 | LittleFS asset serving over WiFi; small bundle size (< 200KB gzipped). | T-F-022 |
| REQ-P-007 | Boot time (power-on to temperature reading) | < 5 seconds | P1 | WiFi connection can happen asynchronously; display and control must start fast. | T-F-009 |
| REQ-P-008 | Temperature control accuracy (steady state) | ±1°C | P1 | Measured at thermocouple; PID must achieve this after settling. | T-F-001 |
| REQ-P-009 | Pressure control accuracy (during profiled shot) | ±0.5 bar | P1 | At steady target; transients during transitions are expected. | T-F-002 |
| REQ-P-010 | Memory usage (free heap during operation) | ≥ 50 KB free | P1 | Ensure no heap exhaustion during WiFi + BLE + display + WebSocket. | T-F-010 |
| REQ-P-011 | Shot log write latency | < 50ms per datapoint write | P2 | LittleFS writes must not block the control loop (runs on separate task/core). | T-F-023 |
| REQ-P-012 | Profile load time (LittleFS read + JSON parse) | < 100ms | P2 | User should not perceive delay when switching profiles. | T-F-024 |
| REQ-P-013 | BLE scale scan + connect time | < 10 seconds from boot | P2 | Scale should be connected before first shot (typical warm-up > 30s). | T-F-012 |

### Usability Requirements

| ID | Requirement | Pri | Verification |
|----|-------------|-----|-------------|
| REQ-U-001 | Temperature display on TFT shall be readable from 1 meter distance (≥ 24pt font, minimum contrast ratio 4.5:1). | P2 | Visual inspection |
| REQ-U-002 | The web app shall be usable on a phone screen (responsive layout, minimum touch target 44×44px). | P2 | Browser test |
| REQ-U-003 | Profile switching shall require ≤ 3 taps/clicks from the idle state. TFT shows top 5 favorites; full list on web app. | P2 | Interaction test |
| REQ-U-004 | The system shall display a fault notification on both TFT and web app, including: fault type, recommended recovery action (e.g., "Thermocouple disconnected — check wiring and power cycle"). | P1 | Fault injection test |
| REQ-U-005 | The TFT display shall turn off or dim after a configurable timeout (default: 5 minutes) when idle. | P3 | Timer test |
| REQ-U-006 | The web app shall not require login for read-only operations (viewing sensors, shot history). | P2 | Browser test |
| REQ-U-007 | First-time setup shall guide the user through WiFi configuration and PIN/password change via the web app. | P2 | Manual test |
| REQ-U-008 | OTA firmware update shall show progress indication on both TFT and web app, with clear error messages on failure. | P2 | OTA test |

### Quality Attributes

| Attribute | Target | Basis | Notes |
|-----------|--------|-------|-------|
| **Reliability** | MTBF > 5000 hours of operation | SSR rated for 100K+ cycles; thermocouple rated for 10K+ hours. Software MTBF driven by watchdog recovery (< 1s). 5000 hours ≈ 2 years of daily use (7 hours/day). | Primary risk: SSR degradation (thyristor wear), thermocouple fatigue (thermal cycling). |
| **Availability** | System usable within 5 seconds of power-on | WiFi/BLE connect asynchronously; PID and display start on boot. | See REQ-P-007. |
| **Maintainability** | Any sensor or actuator replaceable without soldering | JST-XH connectors on all sensor cables. External enclosure opens with 4 screws. | See BOM (section 14). |
| **Portability** | Firmware compiles and runs on any ESP32-S3 dev board | No proprietary dependencies. All libraries open-source (see dependency table in section 9). | |
| **Testability** | Core logic testable on host (x86) without hardware | Pure C++ modules: PID, phase_profiler, predictive_weight, state_machine, config_migration. See module annotations in section 9. | |
| **Security** | Three-tier auth model. No sensitive data exposed. | See REQ-SEC-001 through REQ-SEC-006 and ICD-01 authentication model. | |
| **Recoverability** | System recovers from FAULT state via power cycle or API reset. No data lost on fault. | Shot-in-progress data may be lost (acceptable — safety takes priority over data). Config and completed shots survive faults. | |
| **Interoperability** | REST/WS API designed for third-party integration | Home Assistant, custom dashboards, and community apps can use the API documented in ICD-01. | Not a formal requirement; the API is the enabler. |

---

## 17. Failure Mode and Effects Analysis (FMEA)

Systematic analysis of what happens when each component fails. Severity: 1 (cosmetic) to 5 (safety hazard). Detection: 1 (always detected) to 5 (undetectable). Risk = Severity × Detection.

### Sensor Failures

| Component | Failure Mode | Effect | Severity | Detection | Risk | Mitigation |
|-----------|-------------|--------|----------|-----------|------|------------|
| Thermocouple | Open circuit | MAX31855 reports fault bit. No temperature reading. | 5 | 1 | 5 | REQ-S-003: Disable SSR immediately. REQ-S-001: Thermal fuse provides hardware backup. |
| Thermocouple | Short circuit | MAX31855 reports fault bit. Reading stuck at ~0°C. | 5 | 1 | 5 | REQ-S-003: Fault bit detected → SSR off. |
| Thermocouple | Reads low (degraded) | PID over-heats boiler because it thinks temp is lower than actual. | 5 | 3 | 15 | REQ-S-004: 170°C software ceiling. REQ-S-001: 190°C thermal fuse. Rate-of-change monitoring (> 10°C/s = fault). |
| Pressure transducer | Disconnected | ADS1115 reads 0V or floating. Pressure reads 0 or garbage. | 3 | 2 | 6 | Range check: reading < -0.5 bar or > 15 bar → fault. |
| Pressure transducer | Reads high | Pump may reduce power unnecessarily. Shot quality degrades. | 2 | 3 | 6 | OPV provides mechanical pressure limit regardless of sensor. |
| Pressure transducer | Reads low | Pump may over-pressurize. | 4 | 3 | 12 | OPV limits pressure to ~9 bar (adjusted). Software limit REQ-S-005 at 13 bar. |
| Flow sensor | Stuck (no pulses) | Flow reads 0. System may overshoot on flow-profiled phases. | 3 | 2 | 6 | Timeout: if pump is on but flow = 0 for > 10s, warn user. |
| Flow sensor | Noisy (extra pulses) | Flow reads too high. Pump may reduce power early. | 2 | 3 | 6 | Debouncing in ISR. Moving average filter. |
| BLE scales | Disconnected mid-shot | Weight reads -1 (unavailable). Weight-based stop conditions disabled. | 2 | 1 | 2 | Fallback to volume-based or time-based stop. Predictive weight as backup. |
| ADS1115 (ADC) | I2C bus hang | No pressure readings. | 4 | 1 | 4 | REQ-S-003 (no readings for 200ms → fault). I2C bus recovery (clock stretch reset). |

### Actuator Failures

| Component | Failure Mode | Effect | Severity | Detection | Risk | Mitigation |
|-----------|-------------|--------|----------|-----------|------|------------|
| SSR | Stuck ON (shorted) | Boiler heats continuously. | 5 | 2 | 10 | REQ-S-008: Stuck SSR detection (temp rising after off command). REQ-S-001: Thermal fuse opens at 190°C. |
| SSR | Stuck OFF (open) | Boiler doesn't heat. Machine unusable but safe. | 1 | 1 | 1 | Temperature not reaching setpoint → user notified. |
| Dimmer/Triac | Stuck ON | Pump runs at full power. Over-pressure possible. | 4 | 2 | 8 | OPV limits mechanical pressure. Pressure sensor detects over-pressure → REQ-S-005. |
| Dimmer/Triac | Stuck OFF | Pump doesn't run. No espresso, but safe. | 1 | 1 | 1 | No mitigation needed (fail-safe). |
| Solenoid relay | Stuck ON (open) | 3-way valve stays open. Water drains from group during brew. | 2 | 2 | 4 | Pressure and flow anomaly detection. |
| Solenoid relay | Stuck OFF (closed) | 3-way valve stays closed. Normal brew works. Backflush doesn't. | 1 | 2 | 2 | User notices backflush failure. |

### Controller Failures

| Component | Failure Mode | Effect | Severity | Detection | Risk | Mitigation |
|-----------|-------------|--------|----------|-----------|------|------------|
| ESP32-S3 | Software hang (infinite loop) | All outputs stuck in last state. | 5 | 1 | 5 | REQ-S-006: Watchdog resets MCU within 500ms → GPIOs go to safe state. |
| ESP32-S3 | Hard fault / crash | MCU resets. | 3 | 1 | 3 | GPIO defaults to safe state on reset (REQ-S-002, REQ-S-009). |
| ESP32-S3 | Power loss to MCU | Electronics off, but mains still powered. SSR off (no control signal). | 2 | 1 | 2 | Pull-down resistors ensure actuators off when MCU unpowered. |
| ESP32-S3 | WiFi stack crash | No web UI, no WebSocket. TFT display still works. PID still runs. | 1 | 2 | 2 | WiFi runs on Core 1. Control runs on Core 0. WiFi crash does not affect control. |
| 5V PSU | Failure | No power to MCU/electronics. All actuators off (pull-downs). | 2 | 1 | 2 | Fail-safe by design. Thermal fuse provides boiler protection. |

### Highest Risk Items (Risk ≥ 10)

| Risk | Item | Primary Mitigation |
|------|------|-------------------|
| 15 | Thermocouple reads low (degraded) | Thermal fuse (190°C) + rate-of-change monitoring |
| 10 | SSR stuck ON | Stuck SSR detection + thermal fuse |
| 12 | Pressure transducer reads low | OPV (mechanical) + software pressure limit |

---

## 18. Verification & Test Plan

Each test maps to one or more requirements from section 16.

### Safety Verification Tests

| Test ID | Requirements | Test Procedure | Pass Criteria |
|---------|-------------|----------------|---------------|
| T-S-001 | REQ-S-001 | Inspect installation: verify thermal fuse is wired in series with boiler element, mounted in upper thermostat slot with thermal paste. | Physical inspection confirms correct wiring. Continuity test shows fuse is closed at room temperature. |
| T-S-002 | REQ-S-002, REQ-S-009 | Power-cycle the MCU. Measure voltage on GPIO39 (SSR), GPIO41 (dimmer), GPIO42 (solenoid) during reset. | All three pins read < 0.3V within 1ms of reset. |
| T-S-003 | REQ-S-003 | Disconnect thermocouple while system is running. Measure time from disconnect to SSR GPIO going LOW. | SSR off within 100ms. System enters FAULT state. TFT/web show fault notification. |
| T-S-004 | REQ-S-004 | Heat boiler with PID setpoint at 170°C. Verify SSR disables at limit. | SSR turns off at 170°C. System enters FAULT state. |
| T-S-005 | REQ-S-005 | Block portafilter fully. Run pump at high power. Verify system stops pump at 13 bar. | Pump stops, solenoid opens. System enters FAULT state. (OPV will limit pressure before this in practice.) |
| T-S-006 | REQ-S-006 | Insert `while(true){}` in control task (test build only). Verify watchdog resets MCU. | MCU resets within 500ms. GPIOs go to safe state. System reboots. |
| T-S-007 | REQ-S-007 | Set brew temp to 93°C. Leave system heating for 20+ minutes. | SSR disables at 20 minutes. Notification shown. |
| T-S-008 | REQ-S-008 | Simulate stuck SSR: after SSR off command, inject rising temperature readings. | System detects temp rise > 5°C within 3s of off command. Enters FAULT state. |
| T-S-009 | REQ-S-010 | Measure resistance between mains earth pin and Gaggia chassis with multimeter. | < 0.1Ω. |
| T-S-010 | REQ-S-011 | Inspect internal wiring. Verify high-voltage and low-voltage cables are physically separated. | Visual inspection: minimum 10mm separation or shielding between AC and signal wires. |

### Functional Verification Tests

| Test ID | Requirements | Test Procedure | Pass Criteria |
|---------|-------------|----------------|---------------|
| T-F-001 | REQ-F-001, REQ-P-008 | Set brew temp to 93°C. Wait for steady state. Log temperature for 5 minutes. | Temperature stays within 93°C ± 1°C after initial settling. |
| T-F-002 | REQ-F-002, REQ-P-009 | Run a flat 9-bar profile. Log pressure during extraction (after ramp). | Pressure stays within 9.0 ± 0.5 bar during steady extraction. |
| T-F-003 | REQ-F-003, REQ-F-004, REQ-F-005 | Load a 3-phase test profile (PI at 3 bar for 8s → ramp to 9 bar → hold until 36g). Execute shot. | All three phases execute. Phase transitions occur at correct stop conditions. Shot stops at 36g. |
| T-F-004 | REQ-F-012, REQ-SEC-002 | Upload firmware via web UI OTA endpoint with correct password. | Firmware updates successfully. System reboots with new version. |
| T-F-005 | REQ-F-012, REQ-SEC-001, REQ-SEC-002 | Attempt OTA upload without password or with wrong password. Attempt REST write without session token. | OTA rejected with 401. REST write rejected with 401. Firmware and data unchanged. |
| T-F-006 | REQ-F-013, REQ-F-015, REQ-F-024 | Open web app on phone, tablet, and desktop browser via `espresso.local`. Navigate all pages. Test all REST endpoints with curl. | All pages render correctly. All REST endpoints return correct JSON. mDNS resolves. |
| T-F-007 | REQ-F-014, REQ-P-005 | Connect WebSocket client. Start shot. Measure message interval. | Messages arrive at ≥ 10 Hz (≤ 100ms interval). |
| T-F-008 | REQ-P-001 | Instrument control loop with timing. Log loop duration over 1000 iterations. | 99th percentile loop duration < 5ms (200 Hz). |
| T-F-009 | REQ-P-007 | Power on system. Measure time from power-on to first valid temperature reading on TFT. | < 5 seconds. |
| T-F-010 | REQ-P-010 | Monitor free heap during: idle, active shot with WebSocket client, BLE scales connected. | Free heap ≥ 50 KB in all scenarios. |
| T-F-011 | REQ-F-006, REQ-F-007, REQ-F-008, REQ-P-002, REQ-P-003 | Instrument sensor read timestamps during a shot. Log interval between consecutive reads for each sensor. | Temperature: ≤ 100ms intervals (≥ 10 Hz). Pressure: ≤ 20ms intervals (≥ 50 Hz). Flow: interrupt-driven (verify pulses counted). |
| T-F-012 | REQ-F-009, REQ-P-013 | Power on with BLE scales in range. Measure time from boot to first weight reading. | Weight reading received within 10 seconds. Reading rate ≥ 5 Hz. |
| T-F-013 | REQ-F-010, REQ-F-011, REQ-D-001 | Create 20 profiles. Store 50 shot records. Attempt to store 51st shot. | 20 profiles stored successfully. 50 shots stored. 51st shot overwrites oldest (FIFO). |
| T-F-014 | REQ-F-018, REQ-F-019, REQ-F-020 | Enter steam mode (switch steam ON). Enter flush mode (send flush command). Enter descale mode (send descale command). | Steam mode heats to steam setpoint. Flush runs pump and cycles solenoid. Descale runs configured pump cycles. |
| T-F-015 | REQ-F-021 | Start shot via WebSocket with brew switch OFF. Start shot via brew switch. Turn brew switch OFF during shot. | WebSocket start ignored when switch OFF. Brew switch starts shot normally. Switch OFF stops shot immediately. |
| T-F-016 | REQ-F-022, REQ-D-004 | Change config via API, power cycle, verify config persists. Corrupt NVS partition, boot system. | Config survives power cycle. Corrupted NVS falls back to defaults with user notification. |
| T-F-017 | REQ-F-023 | Boot system with WiFi AP unavailable. Verify PID and display function. Then enable WiFi AP. | System operates normally without WiFi. Web app becomes available when WiFi connects. |
| T-F-018 | REQ-F-025, REQ-D-002, REQ-D-003 | Export profile via API. Import profile via API. Import invalid profile (pressure > 15 bar). Export all data via API. | Export returns valid JSON. Import succeeds. Invalid import rejected with error message. Full export includes config + profiles + shots. |
| T-F-019 | REQ-F-026 | Run a shot without BLE scales. Monitor predictive weight output. | Predictive weight begins estimating after flow detected. Weight estimate within ±5g of actual at shot end (verified with manual scale). |
| T-F-020 | REQ-SEC-001, REQ-SEC-003, REQ-SEC-004, REQ-SEC-005 | Attempt to send WebSocket command without auth. Verify default credential change prompt. Send 6 auth attempts in 1 minute. GET /config and check for wifi_password. | Command rejected. Prompt shown. 6th attempt returns 429. wifi_password absent from response. |
| T-F-021 | REQ-P-004 | Measure TFT frame rate during active shot rendering using GPIO toggle on frame complete. | ≥ 15 FPS. |
| T-F-022 | REQ-P-006 | Clear browser cache. Load web app. Measure time from first HTTP request to interactive page. | < 3 seconds on local WiFi. |
| T-F-023 | REQ-P-011 | During a shot, measure time from ShotDataPoint queued to LittleFS write complete. | < 50ms per datapoint. |
| T-F-024 | REQ-P-012 | Switch active profile via API. Measure time from request to profile loaded and applied. | < 100ms. |

### Unit Tests (Host-Side, No Hardware)

| Test ID | Module | Requirements | Description |
|---------|--------|-------------|-------------|
| T-U-001 | PID controller | REQ-F-001, REQ-F-002 | Verify P, I, D terms with known inputs. Test anti-windup (integral freeze when output saturated). Test output clamping. Test zero Kp guard. Test derivative filter. |
| T-U-002 | Phase profiler | REQ-F-003, REQ-F-004, REQ-F-005 | Verify phase transitions for all curve types. Test stop conditions (time, pressure, flow, weight). Test global stop conditions. Test "from current" start value (-1). |
| T-U-003 | Predictive weight | REQ-F-026 | Verify puck resistance calculation. Test output flow detection thresholds. Test force-start at 65ml. |
| T-U-004 | Config migration | REQ-F-027 | Create config at version N. Run migration to version N+1. Verify all fields correctly migrated. Test migration from v1 to v3 (multi-step). |
| T-U-005 | Profile JSON parser | REQ-D-002 | Parse valid profile JSON. Verify all fields populated. Parse invalid JSON (missing fields, out-of-range values). Verify error returned with reason. |
| T-U-006 | State machine | REQ-F-018, REQ-F-019, REQ-F-020, REQ-F-021 | Verify all 8 states reachable. Verify all valid transitions from transition guard table. Verify FAULT reachable from any state. Verify no invalid transitions. Verify brew switch override logic. |
| T-U-007 | Transition curves | REQ-F-003 | Test LINEAR, EASE_IN, EASE_OUT, EASE_IN_OUT, INSTANT with known inputs. Verify outputs match expected values within 0.01. Test boundary conditions (t=0, t=1, t>1). |

### Requirements Traceability Matrix

| Requirement | Design Module(s) | Test(s) | Status |
|-------------|------------------|---------|--------|
| REQ-S-001 | Hardware (thermal fuse) | T-S-001 | Proposed |
| REQ-S-002 | safety/watchdog, main.cpp (safetyGpioInit) | T-S-002 | Proposed |
| REQ-S-003 | safety/fault_handler, control/control_task | T-S-003 | Proposed |
| REQ-S-004 | safety/fault_handler, safety/safety_limits | T-S-004 | Proposed |
| REQ-S-005 | safety/fault_handler, safety/safety_limits | T-S-005 | Proposed |
| REQ-S-006 | safety/watchdog | T-S-006 | Proposed |
| REQ-S-007 | safety/fault_handler | T-S-007 | Proposed |
| REQ-S-008 | safety/fault_handler | T-S-008 | Proposed |
| REQ-S-009 | Hardware (pull-down resistors) | T-S-002 | Proposed |
| REQ-S-010 | Hardware (wiring) | T-S-009 | Proposed |
| REQ-S-011 | Hardware (wiring) | T-S-010 | Proposed |
| REQ-S-012 | Hardware (EMI filter) | Inspection | Proposed |
| REQ-F-001 | control/pid, control/boiler | T-F-001, T-U-001 | Proposed |
| REQ-F-002 | control/pid, control/dimmer | T-F-002, T-U-001 | Proposed |
| REQ-F-003 | profile/phase_profiler | T-F-003, T-U-002 | Proposed |
| REQ-F-004 | profile/phase_profiler | T-F-003, T-U-002 | Proposed |
| REQ-F-005 | profile/phase_profiler | T-F-003, T-U-002 | Proposed |
| REQ-F-006 | sensors/thermocouple | T-F-011 | Proposed |
| REQ-F-007 | sensors/pressure | T-F-011 | Proposed |
| REQ-F-008 | sensors/flow | T-F-011 | Proposed |
| REQ-F-009 | connectivity/ble_scales | T-F-012 | Proposed |
| REQ-F-010 | config/storage | T-F-013 | Proposed |
| REQ-F-011 | config/storage | T-F-013 | Proposed |
| REQ-F-012 | connectivity/ota, ui/web_server | T-F-004, T-F-005 | Proposed |
| REQ-F-013 | ui/web_server | T-F-006 | Proposed |
| REQ-F-014 | ui/websocket | T-F-007 | Proposed |
| REQ-F-015 | ui/web_server | T-F-006 | Proposed |
| REQ-F-016 | ui/display | Visual inspection | Proposed |
| REQ-F-017 | ui/display | Visual inspection | Proposed |
| REQ-F-018 | control/state_machine, control/boiler | T-F-014, T-U-006 | Proposed |
| REQ-F-019 | control/state_machine, control/dimmer | T-F-014, T-U-006 | Proposed |
| REQ-F-020 | control/state_machine | T-F-014, T-U-006 | Proposed |
| REQ-F-021 | control/control_task, control/state_machine | T-F-015, T-U-006 | Proposed |
| REQ-F-022 | config/config, config/storage | T-F-016 | Proposed |
| REQ-F-023 | connectivity/wifi_manager | T-F-017 | Proposed |
| REQ-F-024 | connectivity/wifi_manager (mDNS) | T-F-006 | Proposed |
| REQ-F-025 | ui/web_server, config/storage | T-F-018 | Proposed |
| REQ-F-026 | profile/predictive_weight | T-F-019, T-U-003 | Proposed |
| REQ-F-027 | config/migration | T-U-004 | Proposed |
| REQ-SEC-001 | ui/web_server, ui/websocket | T-F-005, T-F-020 | Proposed |
| REQ-SEC-002 | ui/web_server, connectivity/ota | T-F-004, T-F-005 | Proposed |
| REQ-SEC-003 | ui/web_server | T-F-020 | Proposed |
| REQ-SEC-004 | ui/web_server | T-F-020 | Proposed |
| REQ-SEC-005 | ui/web_server | T-F-020 | Proposed |
| REQ-SEC-006 | ui/web_server | Code review | Proposed |
| REQ-D-001 | config/storage | T-F-013 | Proposed |
| REQ-D-002 | profile/profile, ui/web_server | T-F-018, T-U-005 | Proposed |
| REQ-D-003 | ui/web_server, config/storage | T-F-018 | Proposed |
| REQ-D-004 | config/config, config/storage | T-F-016 | Proposed |
| REQ-P-001 | control/control_task | T-F-008 | Proposed |
| REQ-P-002 | sensors/thermocouple | T-F-011 | Proposed |
| REQ-P-003 | sensors/pressure | T-F-011 | Proposed |
| REQ-P-004 | ui/display | T-F-021 | Proposed |
| REQ-P-005 | ui/websocket | T-F-007 | Proposed |
| REQ-P-006 | ui/web_server | T-F-022 | Proposed |
| REQ-P-007 | main.cpp (boot sequence) | T-F-009 | Proposed |
| REQ-P-008 | control/pid | T-F-001 | Proposed |
| REQ-P-009 | control/pid | T-F-002 | Proposed |
| REQ-P-010 | All (system-level) | T-F-010 | Proposed |
| REQ-P-011 | config/storage | T-F-023 | Proposed |
| REQ-P-012 | config/storage, profile/profile | T-F-024 | Proposed |
| REQ-P-013 | connectivity/ble_scales | T-F-012 | Proposed |
| REQ-U-001 | ui/display | Visual inspection | Proposed |
| REQ-U-002 | Web app (frontend) | Browser test | Proposed |
| REQ-U-003 | ui/display, Web app | Interaction test | Proposed |
| REQ-U-004 | ui/display, ui/websocket, safety/fault_handler | T-S-003 (fault shown) | Proposed |
| REQ-U-005 | ui/display | Timer test | Proposed |
| REQ-U-006 | ui/web_server | Browser test | Proposed |
| REQ-U-007 | ui/web_server, Web app | Manual test | Proposed |
| REQ-U-008 | connectivity/ota, ui/display, Web app | T-F-004 | Proposed |

---

## 19. Standards Review & Gap Analysis

This section captures the initial gap analysis performed against applicable industry standards. **All P0 and P1 items have been closed** in sections 10, 14, 16, 17, and 18. Each subsection below has been updated inline to show current status. See section 21 for the full closure matrix.

Since this is a personal-use DIY modification (not a commercial product), formal certification is not required. However, applying these standards as a design checklist improves safety, quality, and maintainability.

### Applicable Standards

| Standard | Title | Relevance | Required? |
|----------|-------|-----------|-----------|
| **IEEE 29148** (replaces IEEE 830) | Systems and Software Engineering — Requirements Engineering | Software requirements specification structure | No (personal project), but useful as a quality checklist |
| **IEEE 1016** | Software Design Descriptions | Software design document structure and viewpoints | No, but useful for completeness |
| **IEC 60335-1** | Safety of Household Electrical Appliances — General Requirements | General safety for mains-powered heating appliances | Applies to commercial products. Strongly recommended as a safety design guide. |
| **IEC 60335-2-15** | Particular Requirements for Appliances for Heating Liquids | Espresso machine specific: boiler, overheating, pressure relief | Applies to commercial products. Critical safety reference. |
| **IEC 61508** | Functional Safety of E/E/PE Safety-Related Systems | Safety integrity levels (SIL) for safety functions like over-temperature shutdown | Formal SIL certification not required for personal use. Principles are valuable. |
| **IEC 62443-4-2** | Technical Security Requirements for IACS Components (Embedded Devices) | Cybersecurity for WiFi/BLE-connected embedded devices | Not required for personal use. Good practice for a network-connected device. |
| **EMC Directive 2014/30/EU** | Electromagnetic Compatibility | Emission limits and immunity for electronic equipment | Required only if product is sold in EU. Good practice for any device with AC dimmers and switch-mode power supplies. |
| **Low Voltage Directive 2014/35/EU** | Electrical Equipment for Use Within Certain Voltage Limits | Safety of equipment operating between 50-1000V AC | Required only if product is sold in EU. Critical reference for mains wiring design. |
| **Radio Equipment Directive 2014/53/EU** | Radio Equipment (WiFi, BLE) | Requirements for radio-emitting equipment | Required only if product is sold in EU. ESP32-S3 module should already be RED/FCC certified. |

### Gap Analysis: IEEE 29148 (Software Requirements Specification)

IEEE 29148 defines the required structure for a Software Requirements Specification (SRS). Our design document is a combined SRS + SDD (design description), which is appropriate for a single-person project. Here's what's present and what's missing:

| IEEE 29148 Section | Status | Notes |
|---------------------|--------|-------|
| 1.1 Purpose | **Present** | Scope statement at top of document |
| 1.2 Scope | **Present** | Target machine, what's in/out of scope |
| 1.3.1 Product perspective | **Present** | Current state architecture analysis of prior art (Gaggiuino) |
| 1.3.2 Product functions | **Present** | Sections 3, 9, 11 (software architecture, profile engine) |
| 1.3.3 User characteristics | **Missing** | No description of target user (experience level, technical ability) |
| 1.3.4 Limitations | **Partial** | Hardware constraints documented, but not explicit as "limitations" section |
| 1.4 Definitions / Glossary | **Missing** | Terms like "OPV", "SSR", "PID", "phase profiling" used without definition |
| 2. References | **Missing** | No list of referenced documents, datasheets, or prior art |
| 3.1 Functional requirements | **Partial** | Functions described narratively but not as numbered, testable requirements |
| 3.2 Performance requirements | **Missing** | No explicit PID loop rate, sensor polling rate, display refresh rate requirements |
| 3.3 Usability requirements | **Missing** | No explicit usability goals (e.g., "readable at 1m distance", "configurable in < 5 taps") |
| 3.4 Interface requirements | **Present** | Section 8 API design (REST + WebSocket), section 4 UART protocol |
| 3.5 Data requirements | **Present** | Section 12 data model (config, shot log) |
| 3.6 Quality attributes | **Missing** | No explicit reliability, availability, maintainability targets |
| 4. Verification | **Missing** | No traceability between requirements and test cases |

### Gap Analysis: IEEE 1016 (Software Design Description)

| IEEE 1016 Section | Status | Notes |
|---------------------|--------|-------|
| System architecture / decomposition | **Present** | Section 9 task architecture, module decomposition |
| Design viewpoints (context, composition, logical, dependency, interface, structure, interaction, state, algorithm, resource) | **Partial** | Context, composition, state (safety state machine), and interface viewpoints covered. Missing: dependency, resource, algorithm viewpoints |
| Design entities and relationships | **Partial** | Module decomposition present. Inter-task communication present. Missing: explicit dependency graph between modules |
| Design rationale / decisions | **Present** | Sections 7, 8, 14-16 all document decisions with rationale |
| Human interface design | **Partial** | TFT screen layouts described. Web app pages listed. No wireframes or detailed UI flows. |

### Gap Analysis: IEC 60335-1 / IEC 60335-2-15 (Appliance Safety)

This is the most safety-critical standard. Even for personal use, these requirements should be treated seriously — this device controls mains voltage, a heating element, and pressurized water.

| IEC 60335 Requirement | Status | Gap |
|------------------------|--------|-----|
| **Over-temperature protection** | **CLOSED** | Software limit at 170°C (section 10) + hardware thermal fuse at 184-192°C (section 10, BOM). Defense-in-depth: software, watchdog, and passive hardware layers. |
| **Thermal cutout** | **CLOSED** | Thermal fuse (184-192°C) in upper thermostat slot replaces the removed bimetal thermostat. See section 10 "Layer 3: Hardware Thermal Fuse." |
| **Protective earthing** | **CLOSED** | Documented in section 10 "Protective Earthing": chassis ground, SSR heatsink bonding, enclosure bonding, factory earth preservation. |
| **Creepage / clearance distances** | **Not addressed** | Minimum distances between mains-voltage traces and low-voltage traces on any custom PCB. Relevant if designing a custom board. |
| **Abnormal operation test** | **CLOSED** | FMEA in section 17 covers: dry pump, sensor wire breaks, stuck SSR, MCU crash, power loss, and 21 total failure modes. |
| **Leakage current** | **Not addressed** | Relevant for the AC dimmer and SSR. Off-state leakage through the triac could keep the pump slightly energized. |
| **Pressure relief** | **Present (hardware)** | The OPV (over-pressure valve) is a stock mechanical component and remains in place. Open Espresso does not bypass it. |
| **Stability and mechanical hazards** | **N/A** | Not modified — the Gaggia Classic enclosure is unchanged. |

**Critical finding (RESOLVED): Hardware thermal fuse is now specified in section 10 and BOM (section 14).** Three-layer defense-in-depth model documented.

### Gap Analysis: IEC 61508 (Functional Safety)

IEC 61508 defines Safety Integrity Levels (SIL) for safety-related systems. For a domestic espresso machine, the relevant safety functions are:

| Safety Function | Current Design | SIL Equivalent | Gap |
|----------------|---------------|----------------|-----|
| Over-temperature shutdown | Software (170°C) + hardware thermal fuse (190°C) + watchdog | SIL 1 (met) | **CLOSED** — Three independent layers. See section 10. |
| Over-pressure protection | Mechanical OPV (stock hardware) | N/A (purely mechanical) | Adequate. No software involvement. |
| Sensor failure detection | Software checks + FMEA (section 17) | SIL 1 (met) | **CLOSED** — 21 failure modes analyzed in FMEA. |
| Watchdog timer | ESP32 TWDT, 500ms timeout | SIL 1 (met) | **CLOSED** — GPIO defaults + pull-down resistors ensure safe state. See section 10. |

For a personal-use appliance, formal SIL certification is not required. However, applying SIL 1 principles (single-channel safety function with basic diagnostics) is appropriate and achievable.

**Recommendations from IEC 61508 (all addressed):**
1. ~~Perform a hazard and risk analysis (FMEA)~~ → **CLOSED** — Section 17
2. ~~Document the safe state for each safety function~~ → **CLOSED** — Section 10 (all outputs off)
3. ~~Verify hardware default state on MCU reset is safe~~ → **CLOSED** — Section 10 (GPIO defaults + pull-downs)
4. Use MISRA C guidelines for safety-critical code paths (PID, watchdog, fault detection) — ongoing

### Gap Analysis: IEC 62443-4-2 (Cybersecurity — Embedded Devices)

This device will be WiFi-connected on a home network. While formal cybersecurity certification is not required, the following IEC 62443 principles should be considered:

| Requirement | Status | Notes |
|-------------|--------|-------|
| **Authentication** | **Three-tier model** | Open reads, session-token writes (PIN-based), admin password for OTA/destructive ops. Rate limiting on auth endpoints. WiFi password is write-only in API responses. See ICD-01 Authentication Model. |
| **Firmware integrity** | **Not addressed** | OTA updates should verify firmware signature before flashing. ESP32-S3 supports secure boot and signed OTA. Without this, a compromised network device could push malicious firmware. |
| **Encrypted communication** | **Not addressed** | WebSocket and REST API are over plain HTTP. Consider HTTPS/WSS (ESP32-S3 supports TLS, though CPU-intensive). Lower priority for home LAN. |
| **Secure boot** | **Not addressed** | ESP32-S3 supports hardware secure boot (eFuse-based). Prevents running unsigned firmware. Low priority for personal use, but trivial to enable. |
| **Software update mechanism** | **Present** | OTA firmware update via web UI (section 8). |

**Recommendation (RESOLVED):** Three-tier auth model implemented in ICD-01. OTA password required for firmware upload. Session PIN required for write operations. Signed OTA and secure boot documented as open questions (section 21).

### Gap Analysis: EMC Directive / Radio Equipment Directive

| Concern | Status | Notes |
|---------|--------|-------|
| **AC dimmer EMI** | **CLOSED** | EMI filter and RC snubber added to BOM (section 14). Phase-angle dimming with zero-cross detection + LC input filter + snubber across triac. |
| **Switch-mode PSU EMI** | **Not addressed** | The Hi-Link HLK-PM01 (or similar) AC-DC converter is a switch-mode supply that generates conducted emissions. An input filter capacitor (or using a pre-filtered module) is recommended. |
| **WiFi/BLE emissions** | **Covered by module** | The ESP32-S3-WROOM-1 module is FCC/CE/IC certified. As long as it is used with its integrated antenna without modification, it meets radio emission requirements. |
| **Cable shielding** | **Partial** | Section 15 mentions shielded/twisted-pair wire for signal cables. This is good practice for EMC. |

**Recommendation (RESOLVED):** LC EMI filter and RC snubber added to BOM. See section 14.

### Gap Analysis: Document Structure & Completeness

| Item | Status | Recommendation |
|------|--------|----------------|
| **Glossary / Definitions** | **CLOSED** | Present in front matter — 30+ terms defined. |
| **References** | **CLOSED** | Present in front matter — 12 documents referenced. |
| **Numbered requirements** | **CLOSED** | Section 16 — 39 numbered requirements (REQ-S, REQ-F, REQ-P, REQ-U). |
| **FMEA / Hazard analysis** | **CLOSED** | Section 17 — 21 failure modes with severity/detection/risk scoring. |
| **Test plan** | **CLOSED** | Section 18 — 10 safety tests, 10 functional tests, 7 unit tests, all traced to requirements. |
| **User characteristics** | **CLOSED** | Present in front matter — 5 user roles with technical levels. |
| **Performance requirements** | **CLOSED** | Section 16 — 10 performance requirements (REQ-P-001 through REQ-P-010). |

### Summary: Priority Actions

All items below have been addressed in subsequent sections. See section 21 (Standards Gap Closure Status) for the complete closure matrix.

| Priority | Action | Standard Reference | Status |
|----------|--------|-------------------|--------|
| **P0 — Safety critical** | Add hardware thermal fuse (190°C) in series with boiler element | IEC 60335-1/2-15 | **CLOSED** — Section 10, BOM |
| **P0 — Safety critical** | Verify ESP32-S3 GPIO default state on reset is safe | IEC 61508 | **CLOSED** — Section 10 |
| **P0 — Safety critical** | Document protective earthing requirements | IEC 60335-1 | **CLOSED** — Section 10 |
| **P1 — Important** | Perform FMEA for all sensor/actuator failure modes | IEC 61508 | **CLOSED** — Section 17 |
| **P1 — Important** | Add numbered functional and safety requirements | IEEE 29148 | **CLOSED** — Section 16 |
| **P1 — Important** | Add EMI filter on AC dimmer input | EMC best practice | **CLOSED** — BOM, REQ-S-012 |
| **P1 — Important** | Add password protection to OTA firmware endpoint | IEC 62443-4-2 | **CLOSED** — ICD-01, REQ-F-012 |
| **P2 — Good practice** | Add glossary, references, performance requirements | IEEE 29148 / IEEE 1016 | **CLOSED** — Front matter, Section 16 |
| **P2 — Good practice** | Add test plan mapping to safety requirements | IEEE 29148 | **CLOSED** — Section 18 |
| **P2 — Good practice** | Add snubber circuit to dimmer triac | EMC best practice | **CLOSED** — BOM |
| **P3 — Nice to have** | Enable ESP32-S3 signed OTA and secure boot | IEC 62443-4-2 | **DOCUMENTED** — Open questions |
| **P3 — Nice to have** | Add HTTPS/WSS for web app communication | IEC 62443-4-2 | **DOCUMENTED** — Open questions |
| **P3 — Nice to have** | Add user characteristics and usability requirements | IEEE 29148 | **CLOSED** — Front matter, Section 16 |

---

## 20. Interface Control Documents & APIs

For this to work as a community project, contributors need to be able to work on isolated pieces without understanding the entire system. That means **formal, versioned interface specifications** at every boundary where two components meet.

### Interface Map

```
                            ┌──────────────────────────────────┐
                            │         COMMUNITY CONTRIBUTORS    │
                            │                                   │
                            │  ┌───────────┐  ┌─────────────┐ │
                            │  │ Web App   │  │ iOS/Android │ │
                            │  │ Developer │  │ App Dev     │ │
                            │  └─────┬─────┘  └──────┬──────┘ │
                            │        │               │         │
                            └────────┼───────────────┼─────────┘
                                     │               │
                              ICD-01 │ REST + WS     │ ICD-01 (same API)
                                     │               │
┌─────────────────────────── ESP32-S3 Firmware ───────┴────────────────────┐
│                                     │                                    │
│                              ┌──────┴──────┐                             │
│                              │  Web Server │                             │
│                              │  (Core 1)   │                             │
│                              └──────┬──────┘                             │
│                                     │                                    │
│                              ICD-02 │ Internal Event Bus                 │
│                                     │ (FreeRTOS queues)                  │
│                              ┌──────┴──────┐                             │
│                              │  Control    │                             │
│                              │  Task       │                             │
│                              │  (Core 0)   │                             │
│                              └──┬───┬───┬──┘                             │
│                                 │   │   │                                │
│        ┌────────────────────────┘   │   └──────────────────────┐         │
│  ICD-03│ Sensor HAL          ICD-04│ Actuator HAL        ICD-05│ Profile │
│        │                           │                           │ Format  │
│  ┌─────┴──────┐             ┌──────┴──────┐            ┌──────┴───────┐ │
│  │ Temp/Press │             │ SSR/Dimmer  │            │ JSON Schema  │ │
│  │ Flow/Scale │             │ Solenoid    │            │ (profiles)   │ │
│  └────────────┘             └─────────────┘            └──────────────┘ │
│        │                           │                                     │
│  ICD-06│ BLE Scales                │                                     │
│        │                           │                                     │
│  ┌─────┴──────┐                    │                                     │
│  │ Scale      │                    │                                     │
│  │ Drivers    │                    │                                     │
│  └────────────┘                    │                                     │
│                                    │                                     │
└────────────────────────────────────┴─────────────────────────────────────┘
                                     │
                              ICD-07 │ Hardware Interface
                                     │ (Pin assignments, voltage levels)
                              ┌──────┴──────┐
                              │  Physical   │
                              │  Hardware   │
                              └─────────────┘
```

### ICD-01: REST + WebSocket API (Firmware ↔ Web App / Mobile App)

**Who uses this:** Web app developers, mobile app developers, third-party integrators.

**Why it matters:** This is the primary interface for the community. Anyone building a UI (web, iOS, Android, Home Assistant integration, etc.) depends on this API being stable, versioned, and well-documented.

**Specification:**

#### REST API

All endpoints return JSON. Content-Type: `application/json`.

**Error response format:** `{"error": "Human-readable message", "code": N}` where `code` is the HTTP status code (not an application-specific code).

**HTTP status codes used:**

| Code | Meaning | When |
|------|---------|------|
| 200 | OK | Successful GET, PUT |
| 201 | Created | Successful POST (new resource) |
| 204 | No Content | Successful DELETE |
| 400 | Bad Request | Invalid JSON, validation failure, bad firmware binary |
| 401 | Unauthorized | Missing/invalid session token or OTA password |
| 404 | Not Found | Profile or shot ID does not exist |
| 409 | Conflict | Profile name already exists |
| 429 | Too Many Requests | Rate limit exceeded (auth, OTA) |
| 500 | Internal Server Error | LittleFS write failure, unexpected error |

```
Base URL: http://<device-ip>/api/v1

── Auth ──────────────────────────────────────────────────────

POST   /auth                     → 201 {"token": "abc123..."}
  Body: {"pin": "1234"}          (see Authentication Model below)

── Profiles ──────────────────────────────────────────────────

GET    /profiles                 → 200 ProfileSummary[]
GET    /profiles/:id             → 200 Profile
POST   /profiles                 → 201 Profile (created)            [Auth: session token]
PUT    /profiles/:id             → 200 Profile (updated)            [Auth: session token]
DELETE /profiles/:id             → 204                              [Auth: session token]

── Active Profile ────────────────────────────────────────────

GET    /active-profile           → 200 {"id": N, "name": "..."}
PUT    /active-profile           → 200 {"id": N}                    [Auth: session token]
  Body: {"id": N}

── System Config ─────────────────────────────────────────────

GET    /config                   → 200 SystemConfig (wifi_password redacted)
PUT    /config                   → 200 SystemConfig (updated)       [Auth: session token]
  Body: Partial<SystemConfig>    (only changed fields required)

── Shot History ──────────────────────────────────────────────

GET    /shots                    → 200 ShotSummary[] (newest first)
GET    /shots/:id                → 200 ShotRecord (with datapoints)
DELETE /shots/:id                → 204                              [Auth: session token]
GET    /shots/:id/export         → 200 CSV download (Content-Type: text/csv)

── Data Export/Import ────────────────────────────────────────

GET    /export                   → 200 {"config": ..., "profiles": [...], "shots": [...]}
POST   /profiles/import          → 201 Profile (created)            [Auth: session token]
  Body: Profile JSON (validated per REQ-D-002)

── System ────────────────────────────────────────────────────

GET    /system/info              → 200 {"firmware": "1.0.0", "uptime_s": N,
                                    "free_heap": N, "wifi_rssi": N,
                                    "api_version": "v1", "defaults_active": true}
POST   /system/ota               → 200 {"ok": true}                [Auth: OTA password]
  Header: X-OTA-Password: <password>    (REQUIRED - see REQ-F-012)
  Returns 401 if password missing/incorrect.
  Returns 400 if firmware binary is invalid.
  Password is stored in NVS, set via /config.
POST   /system/restart           → 200 {"ok": true}                [Auth: OTA password]
  Header: X-OTA-Password: <password>    (REQUIRED - destructive action)
POST   /system/factory-reset     → 200 {"ok": true}                [Auth: OTA password]
  Header: X-OTA-Password: <password>    (REQUIRED - destructive action)
```

**Response types:**

```json
// ProfileSummary (returned by GET /profiles)
{
  "id": 1,
  "name": "Classic 9 Bar",
  "phases": 2,                // number of phases
  "is_active": true           // is this the currently active profile?
}

// ShotSummary (returned by GET /shots)
{
  "id": 42,
  "timestamp": 1708123456,   // Unix timestamp (seconds since epoch)
  "profile_name": "Classic 9 Bar",
  "duration_ms": 28000,
  "total_weight_g": 36.2,    // -1 if no scales connected
  "total_volume_ml": 44.1
}
```
```

**Versioning:** The `/api/v1` prefix allows breaking changes in `/api/v2` while keeping v1 working. The version is also returned in `GET /system/info`.

#### Authentication Model

Three tiers of access:

| Tier | Scope | Mechanism | Why |
|------|-------|-----------|-----|
| **Open** | Read-only: `GET /sensors`, `GET /profiles`, `GET /shots`, WebSocket sensor stream | None | Convenient for monitoring from any device on the network |
| **Session** | Write operations: `PUT /config`, `POST /profiles`, `DELETE /shots`, WebSocket commands (`start_shot`, `set_temp`, etc.) | Session token via `POST /api/v1/auth` with PIN | Prevents accidental/unauthorized changes from any device on the WiFi |
| **Admin** | Destructive: OTA upload, restart, factory-reset | OTA password via `X-OTA-Password` header | Prevents bricking or wiping the device |

```
── Session Token Flow ────────────────────────────────────────

POST /api/v1/auth
  Body: {"pin": "1234"}               // Default PIN: 1234 (user must change via config)
  Response: {"token": "abc123..."}     // 32-byte random token, valid until reboot

All write endpoints require:
  Header: Authorization: Bearer <token>
  Returns 401 if missing/invalid.

WebSocket commands require auth message after connection:
  {"type": "auth", "token": "abc123..."}
  Server responds: {"type": "auth_ok"} or {"type": "auth_fail"}
  Unauthenticated clients receive sensor data but cannot send commands.

── Rate Limiting ─────────────────────────────────────────────

POST /api/v1/auth:   Max 5 attempts per minute. Returns 429 after limit.
POST /system/ota:    Max 3 attempts per minute. Returns 429 after limit.
POST /system/restart: Max 1 per 10 seconds.
POST /system/factory-reset: Max 1 per 60 seconds.
```

**Default credentials:** PIN is `1234`, OTA password is `openespresso`. Both must be changed by the user during first setup. The web app prompts for this on first connection if defaults are still active.

**WiFi password protection:** `GET /config` never returns `wifi_password` in the response body. The field is write-only (accepted on `PUT /config` but replaced with `"********"` in `GET` responses).

#### WebSocket Protocol

```
Endpoint: ws://<device-ip>/ws

── Server → Client messages ──────────────────────────────────

Sensor state (sent every 1s when idle, every 100ms during shot):
{
  "type": "sensors",
  "temp": 93.1,            // boiler temperature (°C)
  "pressure": 8.7,         // brew pressure (bar)
  "flow": 2.1,             // pump flow rate (ml/s)
  "weight": 24.3,          // scale weight (g), -1 if no scales
  "target_temp": 93.0,     // target temperature (°C)
  "target_pressure": 9.0,  // target pressure (bar), -1 if N/A
  "target_flow": -1,       // target flow (ml/s), -1 if N/A
  "pump_pct": 72,          // pump power percentage (0-100)
  "state": "brewing",      // idle|heating|ready|brewing|steaming|flushing|fault
  "phase": 2,              // current profile phase index (-1 if not brewing)
  "shot_time_ms": 12300,   // ms since shot start (0 if not brewing)
  "water_pumped_ml": 42.1  // total water pumped this shot
}

State change (sent on transition):
{
  "type": "state_change",
  "from": "heating",
  "to": "ready"
}

Notification:
{
  "type": "notification",
  "level": "info|warning|error",
  "message": "Thermocouple fault detected"
}

Shot complete:
{
  "type": "shot_complete",
  "shot_id": 42,
  "duration_ms": 28000,
  "total_weight_g": 36.2,
  "total_volume_ml": 44.1
}

── Client → Server messages ──────────────────────────────────

Auth (must be first command after connection for write access):
  {"type": "auth", "token": "abc123..."}

Command (requires prior auth):
{
  "type": "command",
  "action": "tare_scales|start_shot|stop_shot|set_active_profile|set_temp",
  "params": {}              // action-specific parameters
}

Examples:
  {"type": "auth", "token": "abc123..."}
  {"type": "command", "action": "tare_scales"}
  {"type": "command", "action": "set_active_profile", "params": {"id": 3}}
  {"type": "command", "action": "set_temp", "params": {"temp_c": 94.0}}

Commands sent without prior auth receive:
  {"type": "error", "message": "Authentication required", "code": 401}

── Heartbeat ─────────────────────────────────────────────────

Server sends ping every 5s. Client must respond with pong.
If no pong received within 15s, server closes connection.
```

**Document location:** `docs/icd-01-rest-websocket-api.md`

### ICD-02: Internal Event Bus (Control Task ↔ UI Task ↔ BLE Task)

**Who uses this:** Firmware contributors adding new features, new sensor support, or new actuators.

**Why it matters:** Defines how tasks communicate without shared global state. Any new firmware module must send/receive through these queues.

**Specification:**

```cpp
// ── Queue: sensor_data_queue (Control → UI, BLE → Control) ──

struct SensorData {
  uint32_t timestamp_ms;
  float temperature_c;
  float pressure_bar;
  float flow_ml_s;
  float weight_g;          // -1 if no scales
  float water_pumped_ml;
  float pump_power_pct;
  int8_t phase_index;      // -1 if not in a shot
  MachineState state;
};
// Queue depth: 4 items. Overwrite oldest on full.

// ── Queue: shot_data_queue (Control → UI for graphing/logging) ──

struct ShotDataPoint {
  uint32_t time_ms;        // relative to shot start
  float temperature_c;
  float pressure_bar;
  float flow_ml_s;
  float weight_g;
  float target_pressure;
  float target_flow;
  float target_temp;
  uint8_t phase_index;
};
// Queue depth: 16 items. Overwrite oldest on full.

// ── Queue: command_queue (UI → Control) ──

enum class CommandType {
  START_SHOT,
  STOP_SHOT,
  SET_ACTIVE_PROFILE,
  SET_BREW_TEMP,
  SET_STEAM_TEMP,
  TARE_SCALES,
  START_FLUSH,
  STOP_FLUSH,
  START_DESCALE,
  ENTER_STEAM_MODE,
  EXIT_STEAM_MODE,
  UPDATE_PID_PARAMS,
};

struct Command {
  CommandType type;
  union {
    uint8_t profile_id;
    float temperature_c;
    struct { float kp, ki, kd; } pid_params;
  } payload;
};
// Queue depth: 8 items. Block on full (commands must not be dropped).

// ── Queue: scale_data_queue (BLE Task → Control Task) ──

struct ScaleData {
  float weight_g;
  bool stable;
  bool connected;
};
// Queue depth: 4 items. Overwrite oldest on full.

// ── Queue: notification_queue (Control → UI) ──

struct Notification {
  enum Level { INFO, WARNING, ERROR } level;
  char message[64];
};
// Queue depth: 8 items. Drop oldest on full.

// ── Machine State Enum (shared across all tasks, read-only except Control) ──

enum class MachineState : uint8_t {
  IDLE,
  HEATING,
  READY,
  BREWING,
  STEAMING,
  FLUSHING,
  DESCALING,
  FAULT,
};
```

**Document location:** `docs/icd-02-internal-event-bus.md`

### ICD-03: Sensor Hardware Abstraction Layer (HAL)

**Who uses this:** Contributors adding new sensor types, porting to different ADCs or thermocouple ICs.

**Why it matters:** Decouples sensor reading logic from specific hardware. Lets you swap ADS1115 for ADS1220 without touching the control loop.

**Specification:**

```cpp
// All sensor drivers implement this interface:

class TemperatureSensor {
public:
  virtual bool begin() = 0;
  virtual float readCelsius() = 0;      // returns NAN (IEEE 754) on fault
  virtual bool hasFault() = 0;
  virtual const char* faultDescription() = 0;  // returns pointer to static string (e.g., "Open circuit"). Never NULL. Returns "" if no fault.
};

class PressureSensor {
public:
  virtual bool begin() = 0;
  virtual float readBar() = 0;          // returns NAN on fault
  virtual bool hasFault() = 0;
};

class FlowSensor {
public:
  virtual bool begin() = 0;
  virtual float readMlPerSecond() = 0;
  virtual float getTotalMl() = 0;
  virtual void resetTotal() = 0;
};

class WeightSensor {
public:
  virtual bool begin() = 0;
  virtual float readGrams() = 0;        // returns NAN if disconnected
  virtual bool isConnected() = 0;
  virtual bool isStable() = 0;
  virtual void tare() = 0;
};

// Concrete implementations:
// - MAX31855TemperatureSensor : TemperatureSensor
// - MAX31856TemperatureSensor : TemperatureSensor (future)
// - ADS1115PressureSensor : PressureSensor
// - ADS1220PressureSensor : PressureSensor (future)
// - HallEffectFlowSensor : FlowSensor
// - BLEWeightSensor : WeightSensor (delegates to BLE scale drivers)
```

**Document location:** `docs/icd-03-sensor-hal.md`

### ICD-04: Actuator Hardware Abstraction Layer (HAL)

**Who uses this:** Contributors working on pump control algorithms, alternative dimmer circuits, or different SSR types.

```cpp
class BoilerController {
public:
  virtual bool begin() = 0;
  virtual void setPower(float percent) = 0;   // 0-100%
  virtual void off() = 0;                     // immediate shutoff
  virtual bool isOn() = 0;
};

class PumpController {
public:
  virtual bool begin() = 0;
  virtual void setPower(float percent) = 0;   // 0-100%
  virtual void off() = 0;
  virtual bool isOn() = 0;
};

class SolenoidController {
public:
  virtual bool begin() = 0;
  virtual void open() = 0;
  virtual void close() = 0;
  virtual bool isOpen() = 0;
};

// Concrete implementations:
// - SSRBoilerController : BoilerController (GPIO, bang-bang)
// - TriacPumpController : PumpController (zero-cross phase-angle dimmer)
// - RelayPumpController : PumpController (future: on/off only, no profiling)
// - RelaySolenoidController : SolenoidController (GPIO relay)
```

**Document location:** `docs/icd-04-actuator-hal.md`

### ICD-05: Profile JSON Schema

**Who uses this:** Web app developers building the profile editor, mobile app developers, users importing/exporting profiles, community profile sharing.

**Why it matters:** This is the most community-visible data format. People will share profiles. It must be stable and well-documented.

**Specification:**

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://espresso.local/schemas/profile-v1.json",
  "title": "Open Espresso Shot Profile",
  "type": "object",
  "required": ["version", "name", "phases"],
  "properties": {
    "version": {
      "type": "integer",
      "const": 1,
      "description": "Schema version. Always 1 for this format."
    },
    "name": {
      "type": "string",
      "maxLength": 32,
      "description": "Human-readable profile name."
    },
    "author": {
      "type": "string",
      "maxLength": 32,
      "description": "Profile creator (for community sharing)."
    },
    "notes": {
      "type": "string",
      "maxLength": 256,
      "description": "Description, recipe notes, grind size, dose, etc."
    },
    "phases": {
      "type": "array",
      "minItems": 1,
      "maxItems": 10,
      "items": {
        "type": "object",
        "required": ["name", "type", "target"],
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 16,
            "description": "Phase name (e.g., 'Pre-infusion', 'Extraction')."
          },
          "type": {
            "enum": ["pressure", "flow"],
            "description": "Control mode for this phase."
          },
          "target": {
            "type": "object",
            "required": ["end"],
            "properties": {
              "start": {
                "type": "number",
                "minimum": -1,
                "maximum": 15,
                "description": "Starting value. -1 = continue from current. Max 15 bar / 10 ml/s."
              },
              "end": {
                "type": "number",
                "minimum": 0,
                "maximum": 15,
                "description": "Target value. Max 15 bar (pressure) or 10 ml/s (flow). See REQ-D-002."
              },
              "curve": {
                "enum": ["instant", "linear", "ease_in", "ease_out", "ease_in_out"],
                "default": "instant"
              },
              "duration_ms": {
                "type": "integer",
                "minimum": 0,
                "maximum": 120000,
                "description": "Transition duration in ms. 0 = instant. Max 120s."
              }
            }
          },
          "restriction": {
            "type": "number",
            "minimum": -1,
            "maximum": 15,
            "description": "Max flow (if type=pressure) or max pressure (if type=flow). -1 = none."
          },
          "temperature_c": {
            "type": "number",
            "minimum": 0,
            "maximum": 170,
            "description": "Target brew temperature for this phase. Max 170°C (REQ-S-004)."
          },
          "stop_conditions": {
            "type": "object",
            "properties": {
              "time_ms":          {"type": "integer", "minimum": 0},
              "pressure_above":   {"type": "number"},
              "pressure_below":   {"type": "number"},
              "flow_above":       {"type": "number"},
              "flow_below":       {"type": "number"},
              "weight_g":         {"type": "number"},
              "water_pumped_ml":  {"type": "number"}
            },
            "description": "Phase advances when ANY condition is met. Omitted conditions are disabled."
          }
        }
      }
    },
    "global_stop_conditions": {
      "type": "object",
      "properties": {
        "time_ms":         {"type": "integer", "minimum": 0},
        "weight_g":        {"type": "number"},
        "water_pumped_ml": {"type": "number"}
      },
      "description": "Shot ends when ANY global condition is met. Omitted = disabled."
    }
  }
}
```

**Document location:** `docs/icd-05-profile-schema.json`

### ICD-06: BLE Scale Driver Interface

**Who uses this:** Contributors adding support for new BLE scale brands.

**Why it matters:** The current Gaggiuino supports 4+ scale brands. New scales appear regularly. A clean driver interface lets the community add support without touching core firmware.

**Specification:**

```cpp
// Every BLE scale driver implements this interface:

class BLEScaleDriver {
public:
  // Metadata
  virtual const char* brandName() = 0;       // e.g., "Acaia"
  virtual const char* modelName() = 0;        // e.g., "Lunar"

  // Connection
  virtual bool matchesAdvertisement(
    const BLEAdvertisedDevice& device) = 0;   // return true if this driver
                                               // handles this device
  virtual bool connect(BLEClient* client) = 0;
  virtual void disconnect() = 0;
  virtual bool isConnected() = 0;

  // Data
  virtual float getWeight() = 0;              // grams, NAN if unavailable
  virtual bool isStable() = 0;
  virtual void tare() = 0;

  // Lifecycle
  virtual void update() = 0;                  // called every ~100ms
                                               // handle heartbeats, etc.
};

/// Registration macro: adds the driver to a global list at compile time.
// Implemented using a static constructor that appends to a linker-set array.
#define REGISTER_SCALE_DRIVER(DriverClass)                        \
  static DriverClass _instance_##DriverClass;                     \
  static BLEScaleDriver* _reg_##DriverClass                       \
    __attribute__((used, section(".scale_drivers")))               \
    = &_instance_##DriverClass;

// Usage (at bottom of each driver .cpp file):
//   REGISTER_SCALE_DRIVER(AcaiaLunarDriver);
//   REGISTER_SCALE_DRIVER(FelicitaArcDriver);
//   REGISTER_SCALE_DRIVER(DecentScaleDriver);
//
// The BLE task iterates the .scale_drivers section at startup,
// calling matchesAdvertisement() on each discovered device to
// find the right driver. No central registration list to maintain.
//
// Alternative (simpler): use a static std::vector and a static
// initializer. The linker-set approach avoids heap allocation at
// startup but requires linker script support.
```

To add a new scale, a contributor:
1. Creates `src/connectivity/scales/my_scale.h/cpp`
2. Implements `BLEScaleDriver` (override all 6 virtual methods)
3. Adds `REGISTER_SCALE_DRIVER(MyScaleDriver)` at the bottom of the `.cpp` file
4. Submits a PR — no changes to any other file required

No changes to core firmware required.

**Document location:** `docs/icd-06-ble-scale-driver.md`

### ICD-07: Hardware Interface (Pin Assignments & Voltage Levels)

**Who uses this:** Hardware designers, PCB contributors, anyone wiring up the system.

**Why it matters:** Exact pin assignments and electrical specs so hardware and firmware stay in sync.

**Specification:**

```
ESP32-S3 Pin Assignments (DevKitC-1 or custom PCB)
────────────────────────────────────────────────────

Function              GPIO    Direction   Interface   Notes
──────────────────    ────    ─────────   ─────────   ─────
TFT_MOSI (display)   GPIO11  OUT         SPI2        Shared SPI bus
TFT_SCLK (display)   GPIO12  OUT         SPI2
TFT_CS (display)     GPIO10  OUT         SPI2
TFT_DC (display)     GPIO9   OUT         GPIO
TFT_RST (display)    GPIO8   OUT         GPIO
TFT_BL (backlight)   GPIO7   OUT         PWM         Brightness control

TOUCH_SDA             GPIO5   I/O         I2C0        CST816 capacitive touch
TOUCH_SCL             GPIO6   OUT         I2C0
TOUCH_INT             GPIO4   IN          GPIO        Interrupt, active low

TC_MISO (thermo)      GPIO13  IN          SPI3        MAX31855 SPI bus
TC_SCLK               GPIO14  OUT         SPI3
TC_CS                  GPIO15  OUT         SPI3

ADC_SDA (pressure)    GPIO17  I/O         I2C1        ADS1115
ADC_SCL               GPIO18  OUT         I2C1

FLOW_PULSE            GPIO16  IN          GPIO/ISR    Hall-effect, interrupt on rising edge

SSR_CTRL              GPIO39  OUT         GPIO        Active HIGH = boiler on
DIMMER_ZC             GPIO40  IN          GPIO/ISR    Zero-cross detect, interrupt
DIMMER_GATE           GPIO41  OUT         GPIO        Triac gate trigger
SOLENOID_CTRL         GPIO42  OUT         GPIO        Active HIGH = valve open

BREW_SWITCH           GPIO2   IN          GPIO        Physical brew switch. HIGH = ON. Internal pull-down.
STEAM_SWITCH          GPIO1   IN          GPIO        Physical steam switch. HIGH = ON. Internal pull-down.

Electrical Levels
─────────────────
All GPIO: 3.3V logic
SSR control: 3.3V logic input (SSR has internal optocoupler)
Dimmer ZC: 3.3V output from optocoupler on dimmer board
Dimmer gate: 3.3V logic (dimmer has gate driver)
Sensor signals: 3.3V (ADS1115 and MAX31855 are 3.3V compatible)

Power
─────
5V input from internal PSU → 3.3V LDO → ESP32-S3 + sensors
Display: 3.3V logic, backlight PWM via GPIO (actual backlight power varies by module — check module schematic)
Total current draw (est.): ~300mA @ 3.3V (ESP32 + WiFi + display + sensors)
```

**Document location:** `docs/icd-07-hardware-interface.md`

### ICD Summary: What Community Members Need

| Role | Needs These ICDs | Can Ignore |
|------|-----------------|------------|
| **Web app developer** | ICD-01 (REST/WS API), ICD-05 (Profile schema) | ICD-02, 03, 04, 06, 07 |
| **iOS/Android app developer** | ICD-01, ICD-05 | ICD-02, 03, 04, 06, 07 |
| **Firmware: new feature** | ICD-02 (event bus), ICD-03 or 04 (HALs) | ICD-01 (unless adding API endpoints) |
| **Firmware: new scale driver** | ICD-06 (BLE scale interface) | Everything else |
| **Hardware: custom PCB** | ICD-07 (pin assignments), ICD-03/04 (HAL specs) | ICD-01, 02, 05 |
| **Profile creator** | ICD-05 (Profile schema) | Everything else |
| **Home Assistant integrator** | ICD-01 (REST/WS API) | Everything else |

### Proposed Repository Structure for Community

```
gaggiuino/
├── firmware/                  # ESP32-S3 firmware (PlatformIO)
│   ├── src/
│   ├── lib/
│   ├── test/
│   └── platformio.ini
│
├── webapp/                    # Web app (separate build, output → firmware/data/)
│   ├── src/
│   ├── package.json
│   └── vite.config.js         # (or svelte.config.js)
│
├── docs/
│   ├── icd-01-rest-websocket-api.md
│   ├── icd-02-internal-event-bus.md
│   ├── icd-03-sensor-hal.md
│   ├── icd-04-actuator-hal.md
│   ├── icd-05-profile-schema.json
│   ├── icd-06-ble-scale-driver.md
│   ├── icd-07-hardware-interface.md
│   ├── safety-fmea.md
│   └── getting-started.md
│
├── profiles/                  # Community-shared profiles
│   ├── classic-9-bar.json
│   ├── turbo-blooming.json
│   └── lungo-flow.json
│
├── hardware/                  # PCB designs (KiCad), enclosure STLs
│   ├── pcb/
│   └── enclosure/
│
├── DESIGN_DOCUMENT.md
├── CONTRIBUTING.md
└── LICENSE
```

**`docs/getting-started.md` must include:** Assembly instructions with wiring diagrams, step-by-step build order, tools needed, and safety warnings. The BOM alone is not sufficient for a safe build. This is the most important document for new builders.

**`CONTRIBUTING.md` must cover:**
1. **Code style:** C++ naming conventions, clang-format config, header guards vs `#pragma once`
2. **Testing:** How to run host-side unit tests, what coverage is expected for new code
3. **Safety-critical code review:** Any PR touching files in `src/safety/`, `src/control/boiler.*`, `src/control/dimmer.*`, or `safety_limits.h` requires explicit review from a maintainer with embedded/safety experience. These files control mains-voltage actuators and cannot be merged casually.
4. **Adding a BLE scale driver:** Step-by-step guide (create file, implement interface, register macro, test with real hardware, submit PR)
5. **Hardware changes:** PCB or wiring changes require updated schematics and review for safety implications (earthing, creepage, thermal fuse path)

---

## 21. Decisions & Open Questions

### Decided

- [x] **Target machine:** Gaggia Classic (pre-2015/2016 model) only
- [x] **MCU:** ESP32-S3 single MCU (evaluate, fall back to dual-MCU if real-time jitter is a problem)
- [x] **Machine display:** ILI9341 2.8" SPI TFT with capacitive touch, driven by LVGL
- [x] **Remote UI:** HTML5 web app served from ESP32 LittleFS, WebSocket for real-time data
- [x] **iOS app:** Not now. Build the WebSocket/REST API first. Add native app later if web app proves insufficient.
- [x] **Nextion display:** Dropped. Proprietary, vendor lock-in, dated.
- [x] **WiFi requirement:** Acceptable (home use only, stable network)
- [x] **Electronics placement:** External enclosure on rear panel. No bare PCBs inside machine.
- [x] **Mounting method:** Neodymium magnets on rear panel (no drilling). Cable glands for cable pass-through.
- [x] **Inside machine:** Only sensors (sealed), SSR (potted), dimmer (coated), PSU (potted), thermal fuse. No exposed ICs.
- [x] **Hardware thermal fuse:** 190°C thermal fuse in series with boiler element. Non-negotiable safety requirement (REQ-S-001).
- [x] **GPIO pull-downs:** 10kΩ pull-down resistors on SSR, dimmer, solenoid GPIOs (REQ-S-009).
- [x] **EMI filter:** LC filter on dimmer AC input + RC snubber across triac (REQ-S-012).
- [x] **OTA authentication:** Password required for firmware upload, restart, and factory reset.
- [x] **API versioning:** REST API uses /api/v1 prefix. WebSocket protocol versioned.

### Open — Hardware

- [ ] **ESP32-S3 module selection:** WROOM-1 (onboard antenna) vs WROVER (PSRAM + antenna)? PSRAM useful for web server asset caching and shot history.
- [ ] **ADC selection:** Keep ADS1115 (16-bit, I2C, 860 SPS max) or switch to ADS1220 (24-bit, SPI, 2000 SPS)? Higher resolution helps pressure accuracy.
- [ ] **Thermocouple interface:** Keep MAX31855 (SPI, basic) or use MAX31856 (SPI, cold-junction compensation, fault detection)? The MAX31856 has better fault detection built in.
- [ ] **Dimmer module:** Design custom PCB or use off-the-shelf module (e.g., RobotDyn AC dimmer)? Custom PCB can integrate SSR + dimmer + level shifting.
- [ ] **Enclosure fabrication:** 3D-printed PETG (cheap, custom, fast iteration) vs off-the-shelf IP54 ABS project box (proven sealing)? Can start with project box, design custom later.
- [ ] **Custom PCB vs dev boards:** Single custom PCB (ESP32-S3 + ADC + thermocouple IC + connectors) vs ESP32 dev board + breakout modules? Custom PCB is cleaner but has longer lead time.
- [ ] **Cable type:** Silicone-insulated wire (high-temp, flexible) vs PTFE (higher temp rating, stiffer). Silicone is easier to work with.
- [ ] **Thermal fuse type:** Non-resettable (forces investigation, safer) vs resettable bimetal KSD301 (more convenient). Recommend non-resettable for safety.

### Open — Software

- [ ] **Web app framework:** Svelte (recommended — smallest bundle, compiles to vanilla JS, good DX for small teams) vs Preact (React API familiarity in 3KB, fallback if Svelte's learning curve is a barrier) vs vanilla JS (no build step, but harder to maintain as UI grows)?
- [ ] **Framework:** ESP-IDF (native, full control, steeper learning curve) vs Arduino framework on ESP-IDF (easier, some overhead)?
- [ ] **Profile format:** JSON (human-readable, parseable by web app) vs MessagePack (smaller, faster parsing on MCU)?
- [ ] **Shot logging:** Store on ESP32 flash (limited space, ~100-500 shots) vs require web app to capture and store?
- [ ] **BLE scales:** Keep supporting all current brands (Acaia, Felicita, Decent, Bookoo) or start with a subset?
- [ ] **Secure boot:** ESP32-S3 supports eFuse-based secure boot. Low priority for personal use but trivial to enable. Document as optional for community.
- [ ] **Signed OTA:** ESP32-S3 supports firmware signature verification. Prevents flashing tampered firmware. Nice-to-have.
- [ ] **HTTPS/WSS:** TLS for web app communication. CPU-intensive on ESP32. Low priority for home LAN.

### Evaluate During Prototyping

- [ ] Is the 2.8" TFT readable at arm's length during a shot? → If not, upgrade to 3.5" ILI9488
- [ ] Do you actually look at the machine display, or always use the phone? → If phone-only, drop the TFT
- [ ] Is WebSocket latency noticeable for real-time shot monitoring? → Acceptable since TFT handles local display
- [ ] Does the web app feel clunky for daily profile switching? → If so, consider native iOS app
- [ ] Does WiFi/BLE cause dimmer or PID jitter on ESP32-S3? → If so, fall back to dual-MCU
- [ ] Does the thermal fuse trip during normal steam operation (155-165°C)? → If so, increase rating to 200°C

### Standards Gap Closure Status

**IEC 60335 / IEC 61508 / IEC 62443 gaps (from section 19):**

| Gap | Status |
|-----|--------|
| Hardware thermal fuse (P0) | **CLOSED** — Section 10, BOM updated |
| GPIO default state verification (P0) | **CLOSED** — Section 10, code example added |
| Protective earthing documentation (P0) | **CLOSED** — Section 10 |
| FMEA (P1) | **CLOSED** — Section 17 |
| Numbered requirements (P1) | **CLOSED** — Section 16 (66 requirements) |
| EMI filter (P1) | **CLOSED** — BOM updated, REQ-S-012 |
| OTA password (P1) | **CLOSED** — ICD-01 API, three-tier auth model |
| Glossary (P2) | **CLOSED** — Front matter (34 terms) |
| References (P2) | **CLOSED** — Front matter (17 references) |
| Performance requirements (P2) | **CLOSED** — Section 16 (13 performance reqs) |
| Test plan (P2) | **CLOSED** — Section 18 (10 safety, 24 functional, 7 unit tests + traceability matrix) |
| User characteristics (P2) | **CLOSED** — Front matter |
| Usability requirements (P2) | **CLOSED** — Section 16 (8 usability reqs) |
| Secure boot / signed OTA (P3) | **DOCUMENTED** — Open questions, optional |
| HTTPS/WSS (P3) | **DOCUMENTED** — Open questions, optional |

**IEEE 1016 design viewpoint gaps:**

| Viewpoint | Status |
|-----------|--------|
| Context | **CLOSED** — System context diagram in section 9 |
| Composition | **CLOSED** — Module decomposition + module annotations table in section 9 |
| Logical | **PLACEHOLDER** — Class/interface relationship diagram TODO |
| Dependency | **CLOSED** — Third-party library table in section 9 |
| Interface | **CLOSED** — 7 ICDs in section 20 (HTTP codes, types, validation ranges added) |
| Structure | **CLOSED** — RTOS task table with priorities, stack sizes, ISR latency budget |
| Interaction | **PLACEHOLDER** — Sequence diagram TODOs for shot lifecycle, dimmer timing, BLE |
| State dynamics | **CLOSED** — Full 8-state machine with labeled transitions and guard conditions |
| Algorithm | **CLOSED** — PID, transition curves, dimmer. **PLACEHOLDER** for predictive weight |
| Resource | **CLOSED** — Flash partition table, RAM budget, SPI bandwidth, WiFi/BLE coexistence |

**IEEE 29148 requirements gaps:**

| Gap | Status |
|-----|--------|
| Business requirements / ConOps | **CLOSED** — Project objective + operational concept in front matter |
| Stakeholder concerns | **CLOSED** — Stakeholder concern table in front matter |
| Functional requirements (steam, flush, etc.) | **CLOSED** — REQ-F-018 through REQ-F-027 |
| Security requirements | **CLOSED** — REQ-SEC-001 through REQ-SEC-006 |
| Data requirements | **CLOSED** — REQ-D-001 through REQ-D-004 |
| Requirement attributes (rationale, source) | **CLOSED** — All tables updated |
| Requirements → design traceability | **CLOSED** — Traceability matrix in section 18 |
| Test coverage for all requirements | **CLOSED** — T-F-011 through T-F-024 added |

---

*Document version: 3.0*
*Updated: 2026-02-16*
*Project: Open Espresso — open-source firmware for Gaggia Classic (pre-2015)*
